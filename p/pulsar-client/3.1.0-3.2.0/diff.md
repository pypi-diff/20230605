# Comparing `tmp/pulsar_client-3.1.0-cp39-cp39-win_amd64.whl.zip` & `tmp/pulsar_client-3.2.0-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,20 @@
-Zip file size: 3209137 bytes, number of entries: 18
--rw-rw-rw-  2.0 fat  7490048 b- defN 23-Mar-08 02:53 _pulsar.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      828 b- defN 23-Mar-08 02:50 pulsar/__about__.py
--rw-rw-rw-  2.0 fat    64377 b- defN 23-Mar-08 02:50 pulsar/__init__.py
--rw-rw-rw-  2.0 fat     1815 b- defN 23-Mar-08 02:50 pulsar/exceptions.py
--rw-rw-rw-  2.0 fat      836 b- defN 23-Mar-08 02:50 pulsar/functions/__init__.py
--rw-rw-rw-  2.0 fat     6302 b- defN 23-Mar-08 02:50 pulsar/functions/context.py
--rw-rw-rw-  2.0 fat     2115 b- defN 23-Mar-08 02:50 pulsar/functions/function.py
--rw-rw-rw-  2.0 fat     3237 b- defN 23-Mar-08 02:50 pulsar/functions/serde.py
--rw-rw-rw-  2.0 fat     1053 b- defN 23-Mar-08 02:50 pulsar/schema/__init__.py
--rw-rw-rw-  2.0 fat    16569 b- defN 23-Mar-08 02:50 pulsar/schema/definition.py
--rw-rw-rw-  2.0 fat     3480 b- defN 23-Mar-08 02:50 pulsar/schema/schema.py
--rw-rw-rw-  2.0 fat     3425 b- defN 23-Mar-08 02:50 pulsar/schema/schema_avro.py
--rw-rw-rw-  2.0 fat    11560 b- defN 23-Mar-08 02:53 pulsar_client-3.1.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1099 b- defN 23-Mar-08 02:53 pulsar_client-3.1.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      172 b- defN 23-Mar-08 02:53 pulsar_client-3.1.0.dist-info/NOTICE
--rw-rw-rw-  2.0 fat      100 b- defN 23-Mar-08 02:53 pulsar_client-3.1.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       15 b- defN 23-Mar-08 02:53 pulsar_client-3.1.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1491 b- defN 23-Mar-08 02:53 pulsar_client-3.1.0.dist-info/RECORD
-18 files, 7608522 bytes uncompressed, 3206709 bytes compressed:  57.9%
+Zip file size: 3397508 bytes, number of entries: 18
+-rw-rw-rw-  2.0 fat  8493056 b- defN 23-May-29 14:10 _pulsar.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat      828 b- defN 23-May-29 14:08 pulsar/__about__.py
+-rw-rw-rw-  2.0 fat    65903 b- defN 23-May-29 14:08 pulsar/__init__.py
+-rw-rw-rw-  2.0 fat     1815 b- defN 23-May-29 14:08 pulsar/exceptions.py
+-rw-rw-rw-  2.0 fat      836 b- defN 23-May-29 14:08 pulsar/functions/__init__.py
+-rw-rw-rw-  2.0 fat     6302 b- defN 23-May-29 14:08 pulsar/functions/context.py
+-rw-rw-rw-  2.0 fat     2115 b- defN 23-May-29 14:08 pulsar/functions/function.py
+-rw-rw-rw-  2.0 fat     3237 b- defN 23-May-29 14:08 pulsar/functions/serde.py
+-rw-rw-rw-  2.0 fat     1053 b- defN 23-May-29 14:08 pulsar/schema/__init__.py
+-rw-rw-rw-  2.0 fat    16569 b- defN 23-May-29 14:08 pulsar/schema/definition.py
+-rw-rw-rw-  2.0 fat     3662 b- defN 23-May-29 14:08 pulsar/schema/schema.py
+-rw-rw-rw-  2.0 fat     5684 b- defN 23-May-29 14:08 pulsar/schema/schema_avro.py
+-rw-rw-rw-  2.0 fat    11560 b- defN 23-May-29 14:11 pulsar_client-3.2.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1087 b- defN 23-May-29 14:11 pulsar_client-3.2.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      172 b- defN 23-May-29 14:11 pulsar_client-3.2.0.dist-info/NOTICE
+-rw-rw-rw-  2.0 fat      100 b- defN 23-May-29 14:11 pulsar_client-3.2.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       15 b- defN 23-May-29 14:10 pulsar_client-3.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1491 b- defN 23-May-29 14:11 pulsar_client-3.2.0.dist-info/RECORD
+18 files, 8615485 bytes uncompressed, 3395080 bytes compressed:  60.6%
```

## zipnote {}

```diff
@@ -30,26 +30,26 @@
 
 Filename: pulsar/schema/schema.py
 Comment: 
 
 Filename: pulsar/schema/schema_avro.py
 Comment: 
 
-Filename: pulsar_client-3.1.0.dist-info/LICENSE
+Filename: pulsar_client-3.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: pulsar_client-3.1.0.dist-info/METADATA
+Filename: pulsar_client-3.2.0.dist-info/METADATA
 Comment: 
 
-Filename: pulsar_client-3.1.0.dist-info/NOTICE
+Filename: pulsar_client-3.2.0.dist-info/NOTICE
 Comment: 
 
-Filename: pulsar_client-3.1.0.dist-info/WHEEL
+Filename: pulsar_client-3.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: pulsar_client-3.1.0.dist-info/top_level.txt
+Filename: pulsar_client-3.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pulsar_client-3.1.0.dist-info/RECORD
+Filename: pulsar_client-3.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pulsar/__about__.py

```diff
@@ -12,8 +12,8 @@
 # Unless required by applicable law or agreed to in writing,
 # software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 # KIND, either express or implied.  See the License for the
 # specific language governing permissions and limitations
 # under the License.
 #
-__version__='3.1.0'
+__version__='3.2.0'
```

## pulsar/__init__.py

```diff
@@ -123,15 +123,15 @@
         """
         return self._message.data()
 
     def value(self):
         """
         Returns object with the de-serialized version of the message content
         """
-        return self._schema.decode(self._message.data())
+        return self._schema.decode_message(self._message)
 
     def properties(self):
         """
         Return the properties attached to the message. Properties are
         application-defined key/value pairs that will be attached to the
         message.
         """
@@ -285,23 +285,52 @@
         _check_type(str, auth_params_string, 'auth_params_string')
         self.auth = _pulsar.AuthenticationAthenz.create(auth_params_string)
 
 class AuthenticationOauth2(Authentication):
     """
     Oauth2 Authentication implementation
     """
-    def __init__(self, auth_params_string):
+    def __init__(self, auth_params_string: str):
         """
         Create the Oauth2 authentication provider instance.
 
+        You can create the instance by setting the necessary fields in the JSON string.
+
+        .. code-block:: python
+
+            auth = AuthenticationOauth2('{"issuer_url": "xxx", "private_key": "yyy"}')
+
+        The valid JSON fields are:
+
+        * issuer_url (required)
+            The URL of the authentication provider which allows the Pulsar client to obtain an
+            access token.
+        * private_key (required)
+            The URL to the JSON credentials file. It supports the following pattern formats:
+
+            * ``/path/to/file``
+            * ``file:///path/to/file``
+            * ``file:/path/to/file``
+            * ``data:application/json;base64,<base64-encoded-value>``
+
+            The file content or the based64 encoded value is the encoded JSON string that contains
+            the following fields:
+
+            * ``client_id``
+            * ``client_secret``
+        * audience
+            The OAuth 2.0 "resource server" identifier for a Pulsar cluster.
+        * scope
+            The scope of an access request.
+
         Parameters
         ----------
-
-        auth_params_string: str
+        auth_params_string : str
             JSON encoded configuration for Oauth2 client
+
         """
         _check_type(str, auth_params_string, 'auth_params_string')
         self.auth = _pulsar.AuthenticationOauth2.create(auth_params_string)
 
 class AuthenticationBasic(Authentication):
     """
     Basic Authentication implementation
@@ -542,16 +571,16 @@
         block_if_queue_full: bool, default=False
             Set whether `send_async` operations should block when the outgoing message queue is full.
         message_routing_mode: PartitionsRoutingMode, default=PartitionsRoutingMode.RoundRobinDistribution
             Set the message routing mode for the partitioned producer.
 
             Supported modes:
 
-            * `PartitionsRoutingMode.RoundRobinDistribution`
-            * `PartitionsRoutingMode.UseSinglePartition`.
+            * ``PartitionsRoutingMode.RoundRobinDistribution``
+            * ``PartitionsRoutingMode.UseSinglePartition``
         lazy_start_partitioned_producers: bool, default=False
             This config affects producers of partitioned topics only. It controls whether producers register
             and connect immediately to the owner broker of each partition or start lazily on demand. The internal
             producer of one partition is always started eagerly, chosen by the routing policy, but the internal
             producers of any additional partitions are started on demand, upon receiving their first message.
 
             Using this mode can reduce the strain on brokers for topics with large numbers of partitions and when
@@ -718,15 +747,15 @@
         properties: dict, optional
             Sets the properties for the consumer. The properties associated with a consumer can be used for
             identify a consumer at broker side.
         pattern_auto_discovery_period: int, default=60
             Periods of seconds for consumer to auto discover match topics.
         initial_position: InitialPosition, default=InitialPosition.Latest
           Set the initial position of a consumer when subscribing to the topic.
-          It could be either: `InitialPosition.Earliest` or `InitialPosition.Latest`.
+          It could be either: ``InitialPosition.Earliest`` or ``InitialPosition.Latest``.
         crypto_key_reader: CryptoKeyReader, optional
             Symmetric encryption class implementation, configuring public key encryption messages for the producer
             and private key decryption messages for the consumer
         replicate_subscription_state_enabled: bool, default=False
             Set whether the subscription status should be replicated.
         max_pending_chunked_message: int, default=10
           Consumer buffers chunk messages into memory until it receives all the chunks of the original message.
@@ -808,14 +837,15 @@
             # Regex pattern
             c._consumer = self._client.subscribe_pattern(topic.pattern, subscription_name, conf)
         else:
             raise ValueError("Argument 'topic' is expected to be of a type between (str, list, re.pattern)")
 
         c._client = self
         c._schema = schema
+        c._schema.attach_client(self._client)
         self._consumers.append(c)
         return c
 
     def create_reader(self, topic, start_message_id,
                       schema=schema.BytesSchema(),
                       reader_listener=None,
                       receiver_queue_size=1000,
@@ -909,14 +939,15 @@
         if crypto_key_reader:
             conf.crypto_key_reader(crypto_key_reader.cryptoKeyReader)
 
         c = Reader()
         c._reader = self._client.create_reader(topic, start_message_id, conf)
         c._client = self
         c._schema = schema
+        c._schema.attach_client(self._client)
         self._consumers.append(c)
         return c
 
     def get_topic_partitions(self, topic):
         """
         Get the list of partitions for a given topic.
 
@@ -1269,17 +1300,21 @@
         Acknowledge the reception of a single message.
 
         This method will block until an acknowledgement is sent to the broker.
         After that, the message will not be re-delivered to this consumer.
 
         Parameters
         ----------
-
-        message:
+        message : Message, _pulsar.Message, _pulsar.MessageId
             The received message or message id.
+
+        Raises
+        ------
+        OperationNotSupported
+             if ``message`` is not allowed to acknowledge
         """
         if isinstance(message, Message):
             self._consumer.acknowledge(message._message)
         else:
             self._consumer.acknowledge(message)
 
     def acknowledge_cumulative(self, message):
@@ -1291,14 +1326,19 @@
         After that, the messages will not be re-delivered to this consumer.
 
         Parameters
         ----------
 
         message:
             The received message or message id.
+
+        Raises
+        ------
+        CumulativeAcknowledgementNotAllowedError
+            if the consumer type is ConsumerType.KeyShared or ConsumerType.Shared
         """
         if isinstance(message, Message):
             self._consumer.acknowledge_cumulative(message._message)
         else:
             self._consumer.acknowledge_cumulative(message)
 
     def negative_acknowledge(self, message):
```

## pulsar/schema/schema.py

```diff
@@ -34,17 +34,23 @@
     def encode(self, obj):
         pass
 
     @abstractmethod
     def decode(self, data):
         pass
 
+    def decode_message(self, msg: _pulsar.Message):
+        return self.decode(msg.data())
+
     def schema_info(self):
         return self._schema_info
 
+    def attach_client(self, client: _pulsar.Client):
+        self._client = client
+
     def _validate_object_type(self, obj):
         if not isinstance(obj, self._record_cls):
             raise TypeError('Invalid record obj of type ' + str(type(obj))
                             + ' - expected type is ' + str(self._record_cls))
 
 
 class BytesSchema(Schema):
```

## pulsar/schema/schema_avro.py

```diff
@@ -15,14 +15,16 @@
 # KIND, either express or implied.  See the License for the
 # specific language governing permissions and limitations
 # under the License.
 #
 
 import _pulsar
 import io
+import json
+import logging
 import enum
 
 from . import Record
 from .schema import Schema
 
 try:
     import fastavro
@@ -36,14 +38,16 @@
             if record_cls is None and schema_definition is None:
                 raise AssertionError("The param record_cls and schema_definition shouldn't be both None.")
 
             if record_cls is not None:
                 self._schema = record_cls.schema()
             else:
                 self._schema = schema_definition
+            self._writer_schemas = dict()
+            self._logger = logging.getLogger()
             super(AvroSchema, self).__init__(record_cls, _pulsar.SchemaType.AVRO, self._schema, 'AVRO')
 
         def _get_serialized_value(self, x):
             if isinstance(x, enum.Enum):
                 return x.name
             elif isinstance(x, Record):
                 return self.encode_dict(x.__dict__)
@@ -72,16 +76,55 @@
         def encode_dict(self, d):
             obj = {}
             for k, v in d.items():
                 obj[k] = self._get_serialized_value(v)
             return obj
 
         def decode(self, data):
+            return self._decode_bytes(data, self._schema)
+
+        def decode_message(self, msg: _pulsar.Message):
+            if self._client is None:
+                return self.decode(msg.data())
+            topic = msg.topic_name()
+            version = msg.int_schema_version()
+            try:
+                writer_schema = self._get_writer_schema(topic, version)
+                return self._decode_bytes(msg.data(), writer_schema)
+            except Exception as e:
+                self._logger.error('Failed to get schema info of {topic} version {version}: {e}')
+                return self._decode_bytes(msg.data(), self._schema)
+
+        def _get_writer_schema(self, topic: str, version: int) -> 'dict':
+            if self._writer_schemas.get(topic) is None:
+                self._writer_schemas[topic] = dict()
+            writer_schema = self._writer_schemas[topic].get(version)
+            if writer_schema is not None:
+                return writer_schema
+            if self._client is None:
+                return self._schema
+
+            self._logger.info('Downloading schema of %s version %d...', topic, version)
+            info = self._client.get_schema_info(topic, version)
+            self._logger.info('Downloaded schema of %s version %d', topic, version)
+            if info.schema_type() != _pulsar.SchemaType.AVRO:
+                raise RuntimeError(f'The schema type of topic "{topic}" and version {version}'
+                                   f' is {info.schema_type()}')
+            writer_schema = json.loads(info.schema())
+            self._writer_schemas[topic][version] = writer_schema
+            return writer_schema
+
+        def _decode_bytes(self, data: bytes, writer_schema: dict):
             buffer = io.BytesIO(data)
-            d = fastavro.schemaless_reader(buffer, self._schema)
+            # If the record names are different between the writer schema and the reader schema,
+            # schemaless_reader will fail with fastavro._read_common.SchemaResolutionError.
+            # So we make the record name fields consistent here.
+            reader_schema: dict = self._schema
+            writer_schema['name'] = reader_schema['name']
+            d = fastavro.schemaless_reader(buffer, writer_schema, reader_schema)
             if self._record_cls is not None:
                 return self._record_cls(**d)
             else:
                 return d
 
 else:
     class AvroSchema(Schema):
```

## Comparing `pulsar_client-3.1.0.dist-info/LICENSE` & `pulsar_client-3.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pulsar_client-3.1.0.dist-info/METADATA` & `pulsar_client-3.2.0.dist-info/METADATA`

 * *Files 23% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 Metadata-Version: 2.1
 Name: pulsar-client
-Version: 3.1.0
+Version: 3.2.0
 Summary: Apache Pulsar Python client library
 Home-page: https://pulsar.apache.org/
 Author: Pulsar Devs
 Author-email: dev@pulsar.apache.org
 License: Apache License v2.0
 Platform: UNKNOWN
 License-File: LICENSE
 License-File: NOTICE
 Requires-Dist: certifi
 Provides-Extra: all
-Requires-Dist: apache-bookkeeper-client (>=4.9.2) ; extra == 'all'
-Requires-Dist: fastavro (==0.24.0) ; extra == 'all'
-Requires-Dist: grpcio (<1.28,>=1.8.2) ; extra == 'all'
+Requires-Dist: apache-bookkeeper-client (>=4.16.1) ; extra == 'all'
+Requires-Dist: fastavro (==1.7.3) ; extra == 'all'
+Requires-Dist: grpcio (>=1.8.2) ; extra == 'all'
 Requires-Dist: prometheus-client ; extra == 'all'
 Requires-Dist: protobuf (<=3.20.3,>=3.6.1) ; extra == 'all'
 Requires-Dist: ratelimit ; extra == 'all'
 Provides-Extra: avro
-Requires-Dist: fastavro (==0.24.0) ; extra == 'avro'
+Requires-Dist: fastavro (==1.7.3) ; extra == 'avro'
 Provides-Extra: functions
-Requires-Dist: apache-bookkeeper-client (>=4.9.2) ; extra == 'functions'
-Requires-Dist: grpcio (<1.28,>=1.8.2) ; extra == 'functions'
+Requires-Dist: apache-bookkeeper-client (>=4.16.1) ; extra == 'functions'
+Requires-Dist: grpcio (>=1.8.2) ; extra == 'functions'
 Requires-Dist: prometheus-client ; extra == 'functions'
 Requires-Dist: protobuf (<=3.20.3,>=3.6.1) ; extra == 'functions'
 Requires-Dist: ratelimit ; extra == 'functions'
 
 UNKNOWN
```

## Comparing `pulsar_client-3.1.0.dist-info/RECORD` & `pulsar_client-3.2.0.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-_pulsar.cp39-win_amd64.pyd,sha256=J6UxZ25McAmH5xEdZEMICFTX6XjQJwr7vAC5qR0P5Lg,7490048
-pulsar/__about__.py,sha256=JxVwWK_aGKRVPUiAY8K0pM9p9qAXnhdyfkGd-pkWHu4,828
-pulsar/__init__.py,sha256=2eskGYW1Appov_oc_xUjpdwTEGgJhUTaIseTKLIlcZc,64377
+_pulsar.cp39-win_amd64.pyd,sha256=FznomCn6oBw8NkZ5BV7qxDLal4kHGgZ6U2by8i0YBYk,8493056
+pulsar/__about__.py,sha256=3nXcJ7MfgVzFODdun18H-9zX0RnlU_AhAxHJoirBr1U,828
+pulsar/__init__.py,sha256=s2hfBRMSC8DwLm7G3sdNM6iH27wqn6mB0WzP9jIfx1Q,65903
 pulsar/exceptions.py,sha256=wkR_p7sVbkZzT4L9nRVeciRvy2EQAAe0Mj_ah_4ruSg,1815
 pulsar/functions/__init__.py,sha256=bh0kjPKz1jddu_POz5fUBAGVhgY5CwY2ct5k_diMAfE,836
 pulsar/functions/context.py,sha256=0BVO6LURGNeqF1dgO3uPU7GyRN8rO1OeQChnnf-wP_g,6302
 pulsar/functions/function.py,sha256=bB6y5PG2OuQk-CQhzqqVL_kD89VXjTzIZ27PX-rbWzw,2115
 pulsar/functions/serde.py,sha256=B20-iZ5n997u0VXzQVGcaL-OGEG9Wz1-HlzRC8t6NVE,3237
 pulsar/schema/__init__.py,sha256=NyK-AZ6JLnYhoy4F1IL6KMyJnyv3CNHX9aNs1t2Px7g,1053
 pulsar/schema/definition.py,sha256=br3QOWPbRG_VcQtaeuAwjfjU3dQw8-DYhRf_45RF458,16569
-pulsar/schema/schema.py,sha256=bE3hmCvNwleWp4NvQBOnJ4-OQr4GXEX0SFrxnBySIGk,3480
-pulsar/schema/schema_avro.py,sha256=PwpwVIr1VSQUddAfZFxmLftXWyp2qqxMpnDPa0mgnbk,3425
-pulsar_client-3.1.0.dist-info/LICENSE,sha256=Pd-b5cKP4n2tFDpdx27qJSIq0d1ok0oEcGTlbtL6QMU,11560
-pulsar_client-3.1.0.dist-info/METADATA,sha256=GOBb1d9cY9ME1nMGVu21O7VsgfNv1QHaxsdEPLAQQ6A,1099
-pulsar_client-3.1.0.dist-info/NOTICE,sha256=Y2qi3OyZXDvx_Y3vfmx9dTDLp3eYFhBd_ggJbgs0ZuM,172
-pulsar_client-3.1.0.dist-info/WHEEL,sha256=J_4V_gB-O6Y7Pn6lk91K27JaIhI-q07YM5J8Ufzqla4,100
-pulsar_client-3.1.0.dist-info/top_level.txt,sha256=GVhMR8w0BNGzD2N7S4F8rlhGydMUnsygXWjzoY81jEM,15
-pulsar_client-3.1.0.dist-info/RECORD,,
+pulsar/schema/schema.py,sha256=BjcOm5DK1Xl0pMXtCXdFOakN-IMS9VK6V_-xBzFGJr4,3662
+pulsar/schema/schema_avro.py,sha256=xQ8fg2USOi-XLOFvvfwn76EG1Lh-rU3v6WwV2AW51Fk,5684
+pulsar_client-3.2.0.dist-info/LICENSE,sha256=Pd-b5cKP4n2tFDpdx27qJSIq0d1ok0oEcGTlbtL6QMU,11560
+pulsar_client-3.2.0.dist-info/METADATA,sha256=w46ebPlGeKDbHVfkwpBZxrch7Fbir0JKss-c_jejFQ0,1087
+pulsar_client-3.2.0.dist-info/NOTICE,sha256=Y2qi3OyZXDvx_Y3vfmx9dTDLp3eYFhBd_ggJbgs0ZuM,172
+pulsar_client-3.2.0.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
+pulsar_client-3.2.0.dist-info/top_level.txt,sha256=GVhMR8w0BNGzD2N7S4F8rlhGydMUnsygXWjzoY81jEM,15
+pulsar_client-3.2.0.dist-info/RECORD,,
```

