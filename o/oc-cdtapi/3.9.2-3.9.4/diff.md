# Comparing `tmp/oc_cdtapi-3.9.2-py3-none-any.whl.zip` & `tmp/oc_cdtapi-3.9.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,17 +1,17 @@
-Zip file size: 35042 bytes, number of entries: 15
--rw-r--r--  2.0 unx     8680 b- defN 23-May-22 09:13 oc_cdtapi/API.py
--rw-r--r--  2.0 unx     2054 b- defN 23-May-22 09:13 oc_cdtapi/DevPIAPI.py
--rw-r--r--  2.0 unx     7841 b- defN 23-May-22 09:13 oc_cdtapi/DmsAPI.py
--rw-r--r--  2.0 unx    13948 b- defN 23-May-22 09:13 oc_cdtapi/DmsGetverAPI.py
--rw-r--r--  2.0 unx    39979 b- defN 23-May-22 09:13 oc_cdtapi/ForemanAPI.py
--rw-r--r--  2.0 unx    15862 b- defN 23-May-22 09:13 oc_cdtapi/JenkinsAPI.py
--rw-r--r--  2.0 unx    26153 b- defN 23-May-22 09:13 oc_cdtapi/NexusAPI.py
--rw-r--r--  2.0 unx     2715 b- defN 23-May-22 09:13 oc_cdtapi/TestServer.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 09:13 oc_cdtapi/__init__.py
--rwxr-xr-x  2.0 unx     6858 b- defN 23-May-22 09:13 oc_cdtapi-3.9.2.data/scripts/nexus.py
--rw-r--r--  2.0 unx    11357 b- defN 23-May-22 09:13 oc_cdtapi-3.9.2.dist-info/LICENSE
--rw-r--r--  2.0 unx      276 b- defN 23-May-22 09:13 oc_cdtapi-3.9.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-22 09:13 oc_cdtapi-3.9.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-May-22 09:13 oc_cdtapi-3.9.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1196 b- defN 23-May-22 09:13 oc_cdtapi-3.9.2.dist-info/RECORD
-15 files, 137021 bytes uncompressed, 33084 bytes compressed:  75.9%
+Zip file size: 36617 bytes, number of entries: 15
+-rw-r--r--  2.0 unx    12398 b- defN 23-Jun-05 11:09 oc_cdtapi/API.py
+-rw-r--r--  2.0 unx     1836 b- defN 23-Jun-05 11:09 oc_cdtapi/DevPIAPI.py
+-rw-r--r--  2.0 unx     9481 b- defN 23-Jun-05 11:09 oc_cdtapi/DmsAPI.py
+-rw-r--r--  2.0 unx    16085 b- defN 23-Jun-05 11:09 oc_cdtapi/DmsGetverAPI.py
+-rw-r--r--  2.0 unx    39747 b- defN 23-Jun-05 11:09 oc_cdtapi/ForemanAPI.py
+-rw-r--r--  2.0 unx    15748 b- defN 23-Jun-05 11:09 oc_cdtapi/JenkinsAPI.py
+-rw-r--r--  2.0 unx    26122 b- defN 23-Jun-05 11:09 oc_cdtapi/NexusAPI.py
+-rw-r--r--  2.0 unx     2715 b- defN 23-Jun-05 11:09 oc_cdtapi/TestServer.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 11:09 oc_cdtapi/__init__.py
+-rwxr-xr-x  2.0 unx     6858 b- defN 23-Jun-05 11:09 oc_cdtapi-3.9.4.data/scripts/nexus.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Jun-05 11:09 oc_cdtapi-3.9.4.dist-info/LICENSE
+-rw-r--r--  2.0 unx      276 b- defN 23-Jun-05 11:09 oc_cdtapi-3.9.4.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-05 11:09 oc_cdtapi-3.9.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Jun-05 11:09 oc_cdtapi-3.9.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1197 b- defN 23-Jun-05 11:09 oc_cdtapi-3.9.4.dist-info/RECORD
+15 files, 143922 bytes uncompressed, 34659 bytes compressed:  75.9%
```

## zipnote {}

```diff
@@ -21,26 +21,26 @@
 
 Filename: oc_cdtapi/TestServer.py
 Comment: 
 
 Filename: oc_cdtapi/__init__.py
 Comment: 
 
-Filename: oc_cdtapi-3.9.2.data/scripts/nexus.py
+Filename: oc_cdtapi-3.9.4.data/scripts/nexus.py
 Comment: 
 
-Filename: oc_cdtapi-3.9.2.dist-info/LICENSE
+Filename: oc_cdtapi-3.9.4.dist-info/LICENSE
 Comment: 
 
-Filename: oc_cdtapi-3.9.2.dist-info/METADATA
+Filename: oc_cdtapi-3.9.4.dist-info/METADATA
 Comment: 
 
-Filename: oc_cdtapi-3.9.2.dist-info/WHEEL
+Filename: oc_cdtapi-3.9.4.dist-info/WHEEL
 Comment: 
 
-Filename: oc_cdtapi-3.9.2.dist-info/top_level.txt
+Filename: oc_cdtapi-3.9.4.dist-info/top_level.txt
 Comment: 
 
-Filename: oc_cdtapi-3.9.2.dist-info/RECORD
+Filename: oc_cdtapi-3.9.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## oc_cdtapi/API.py

```diff
@@ -9,23 +9,23 @@
 import sys
 
 if sys.version_info.major == 2:
     strtype = basestring
 elif sys.version_info.major == 3:
     strtype = str
 
+
 class HttpAPIError(Exception):
 
     def __init__(self, code=0, url='', resp=None, text=''):
         self.code = code
         self.url = url
         self.resp = resp
         self.text = text
 
-
     def __str__(self):
         return self.text + ': Code ' + str(self.code) + ' ' + self.url
 
 
 class HttpAPI(object):
     """ Base class for implementing HTTP API """
     # This attributes may be re-defined in your child classes
@@ -36,19 +36,19 @@
     # if root, user and auth was not provided to class constructor
     _env_url = '_URL'
     _env_user = '_USER'
     _env_auth = '_PASSWORD'
 
     def __init__(self, root=None, user=None, auth=None, readonly=False, anonymous=False):
         """
-        :param root: Root URL (uses *_URL by default)
-        :param user: Username (uses *_USER by default)
-        :param auth: Password (uses *_PASSWORD by default)
-        :param readonly: sets readonly property, should be explictly supported by child 
-        :param anonymous: ignore username/password provided and use anonymous requests
+        :param str root: Root URL (uses *_URL by default)
+        :param str user: Username (uses *_USER by default)
+        :param str auth: Password (uses *_PASSWORD by default)
+        :param bool readonly: sets readonly property, should be explictly supported by child 
+        :param bool anonymous: ignore username/password provided and use anonymous requests
 
         >>> import os
         >>> from oc_cdtapi.API import HttpAPI
         >>> def test(port):
         ...     HttpAPI._env_prefix='HTTP'
         ...     os.environ['HTTP_URL'] = 'http://127.0.0.1:' + str(port)
         ...     api = HttpAPI()
@@ -63,38 +63,66 @@
         >>> obj_api.root
         'https://127.0.0.1/'
         >>> obj_api.web.verify
         False
         """
 
         self.readonly = readonly
-        if self._env_prefix != None:
-            if not root: root = os.getenv(self._env_prefix + self._env_url)
-            if not user: user = os.getenv(self._env_prefix + self._env_user)
-            if not auth: auth = os.getenv(self._env_prefix + self._env_auth)
-        if not root: raise ValueError('Server URL for service [%s] not set' % self._env_prefix)
+
+        if self._env_prefix is not None:
+            if not root:
+                root = os.getenv(self._env_prefix + self._env_url)
+
+            if not user:
+                user = os.getenv(self._env_prefix + self._env_user)
+
+            if not auth:
+                auth = os.getenv(self._env_prefix + self._env_auth)
+
+        if not root:
+            raise ValueError('Server URL for service [%s] not set' % self._env_prefix)
+
         self.root = root
         self.web = requests.Session()
-        if user != None and not anonymous: self.web.auth = (user, auth)
 
-        if self.root.startswith( "https:" ):
-            self.web.verify = False;
+        if user and not anonymous:
+            self.web.auth = (user, auth)
 
+        if self.root.startswith("https:"):
+            # ignore self-signed certificates warning
+            self.web.verify = False
 
     def set_readonly(self, readonly=True):
+        """
+        Set instance as read-only
+        :param bool readonly: foo
+        """
         self.readonly = readonly
 
-
     def re(self, req):
-        """ Constructs request URL from request name """
-        return posixpath.join(self.root, req)
+        """ 
+        Constructs request URL from request name
+        :param str req: string or list of strings for the request
+        """
+        # do not use 'urlparse.urljoin' here because it gives wrong result if 'root'
+        # contains sub-path. Example:
+        # urlparse.urljoin("https://exapmle.com:5400/c1/c2/c3", "c4/c5/c6")
+        # gives 'https://exapmle.com:5400/c1/c2/c4/c5/c6'
+        # while 'https://exapmle.com:5400/c1/c2/c3/c4/c5/c6' expected ('c3' missing)
+        if isinstance(req, list):
+            req = posixpath.sep.join(req)
 
+        return posixpath.join(self.root, req)
 
     def pp(self, resp, write_to=None, stream=False, **kvarg):
         """ Post-processes response
+        :param requests.Response resp: the response object
+        :param fileObj write_to: file object to write result to
+        :param bool stream: use stream mode (useful for large objects)
+        :param kvarg: another keyword arguments, not actually used
 
         New feature! If write_to parameter is given to any method, that returns response
         object, request result will be written to fd or filename specified in write_to.
 
         If stream == True, file will be written on the fly, without reading all the data
 
         >>> import sys
@@ -143,37 +171,58 @@
         'Read data!'
         >>> os.unlink(tmpfile)
 
         """
 
         if resp.status_code < self.raise_exception_low or resp.status_code > self.raise_exception_high:
             raise self._error(resp.status_code, resp.url, resp, 'Error making request to server')
-        if write_to != None:
-            if isinstance (write_to, strtype):
+
+        if write_to is not None:
+
+            if isinstance(write_to, strtype):
                 fd = open(write_to, 'wb')
             else:
                 fd = write_to
+
             if not stream:
                 fd.write(resp.content)
             else:
                 shutil.copyfileobj(resp.raw, fd)
+
             fd.flush()
-            if isinstance (write_to, strtype): fd.close()
+
+            if isinstance(write_to, strtype):
+                fd.close()
+
             del fd
-        return resp
 
+        return resp
 
     def __kvarg(self, kvarg):
+        """
+        Omit 'write_to' argument
+        :param dict kvarg: keyword arguments
+        :return dict: ditionary without 'write_to' key
+        """
+
         kvarg = kvarg.copy()
-        if 'write_to' in kvarg: del kvarg['write_to']
-        return kvarg
+        if 'write_to' in kvarg:
+            del kvarg['write_to']
 
+        return kvarg
 
     def get(self, req, params=None, files=None, data=None, headers=None, **kvarg):
         """Sends GET request
+        :param str req: request sub-URL
+        :param dict params: additional GET parameters
+        :param files: files to append to the request
+        :param data: additional data to append to the request
+        :param dict headers: additional headers for the request
+        :param kvarg: additional keyword arguments
+        :return requests.Response: postprocessed the response object
 
         >>> def test(port):
         ...     api = HttpAPI('http://127.0.0.1:' + str(port))
         ...     api.get('getrequest')
         ...
         >>> from oc_cdtapi.TestServer import test_wrapper
         >>> test_wrapper(test)
@@ -189,61 +238,108 @@
         ...
         >>> test_wrapper(test, data = 'hello, world!', ret = True)
         "GET /getrequest HTTP/1.1" 200 -
         0
 
         """
 
-        resp = self.web.get(self.re(req), params=params, data=data, files=files, headers=headers, **self.__kvarg(kvarg))
-        return self.pp(resp, **kvarg)
+        resp = self.web.get(self.re(req), params=params, data=data,
+                            files=files, headers=headers, **self.__kvarg(kvarg))
 
+        return self.pp(resp, **kvarg)
 
     def post(self, req, params=None, files=None, data=None, headers=None, **kvarg):
-        """Sends POST request"""
-        resp = self.web.post(self.re(req), params=params, data=data, files=files, headers=headers, **kvarg)
+        """
+        Sends POST request
+        :param str req: request sub-URL
+        :param dict params: additional GET parameters
+        :param files: files to append to the request
+        :param data: additional data to append to the request
+        :param dict headers: additional headers for the request
+        :param kvarg: additional keyword arguments
+        :return requests.Response: postprocessed the response object
+        """
+        resp = self.web.post(self.re(req), params=params,
+                             data=data, files=files, headers=headers, **kvarg)
         return self.pp(resp, **kvarg)
 
-
     def put(self, req, params=None, files=None, data=None, headers=None, **kvarg):
         """Sends PUT request
+        :param str req: request sub-URL
+        :param dict params: additional GET parameters
+        :param files: files to append to the request
+        :param data: additional data to append to the request
+        :param dict headers: additional headers for the request
+        :param kvarg: additional keyword arguments
+        :return requests.Response: postprocessed the response object
+
         >>> def test(port):
         ...     api = HttpAPI('http://127.0.0.1:' + str(port))
         ...     api.put('getrequest')
         ...
         >>> from oc_cdtapi.TestServer import test_wrapper
         >>> test_wrapper(test)
         "PUT /getrequest HTTP/1.1" 200 -
 
         """
 
-        resp = self.web.put(self.re(req), params=params, data=data, files=files, headers=headers, **kvarg)
+        resp = self.web.put(self.re(req), params=params,
+                            data=data, files=files, headers=headers, **kvarg)
         return self.pp(resp, **kvarg)
 
-
     def delete(self, req, params=None, files=None, data=None, headers=None, **kvarg):
-        """Sends DELETE request"""
-        resp = self.web.delete(self.re(req), params=params, data=data, files=files, headers=headers, **kvarg)
+        """
+        Sends DELETE request
+        :param str req: request sub-URL
+        :param dict params: additional GET parameters
+        :param files: files to append to the request
+        :param data: additional data to append to the request
+        :param dict headers: additional headers for the request
+        :param kvarg: additional keyword arguments
+        :return requests.Response: postprocessed the response object
+        """
+        resp = self.web.delete(self.re(req), params=params,
+                               data=data, files=files, headers=headers, **kvarg)
         return self.pp(resp, **kvarg)
 
     def head(self, req, params=None, files=None, data=None, headers=None, **kvarg):
-        """Sends HEAD request"""
-        resp = self.web.head(self.re(req), params=params, data=data, files=files, headers=headers, **kvarg)
+        """
+        Sends HEAD request
+        :param str req: request sub-URL
+        :param dict params: additional GET parameters
+        :param files: files to append to the request
+        :param data: additional data to append to the request
+        :param dict headers: additional headers for the request
+        :param kvarg: additional keyword arguments
+        :return requests.Response: postprocessed the response object
+        """
+        resp = self.web.head(self.re(req), params=params,
+                             data=data, files=files, headers=headers, **kvarg)
         return self.pp(resp, **kvarg)
 
 
 # Two shortcuts to deal with XML without having full XML support
 def get_xml_tag(config, tag):
-    """Gets tag value from xml config"""
+    """
+    Gets tag value from xml config
+    Warning: this method ignores XML-comments and returns the first inclusion only
+    :param str config: xml string
+    :param str tag: tag to get
+    :return str: first tag value found
+    """
     return ((config.split('<' + tag + '>')[1]).split('</' + tag + '>')[0])
 
 
 def edit_xml_tag(config, tag, value):
-    """Sets tag value in xml config. Works fine if there is only single such tag in XML"""
+    """
+    Sets tag value in xml config. Works fine if there is only single such tag in XML
+    Warning: this method ignores XML-comments and returns the first inclusion only
+    :param str config: xml string
+    :param str tag: tag to edit
+    :param str value: value to set
+    :return str: str with replaced tag value
+    """
     config = config.split('<' + tag + '>')[0] + '<' + tag + '>' + value + '</' + tag + '>' + \
-             config.split('</' + tag + '>')[1]
-    return config
+        config.split('</' + tag + '>')[1]
 
+    return config
 
-if __name__ == "__main__":
-    import doctest
-
-    doctest.testmod()
```

## oc_cdtapi/DevPIAPI.py

```diff
@@ -1,57 +1,57 @@
 #!/usr/bin/python2.7
 
 """
 Additional HTTP API for Python Package Index based on DevPI
 """
 
-from .API import HttpAPI;
-import re;
-import xml.etree.ElementTree as ET;
-import posixpath;
+from .API import HttpAPI
+import re
+import xml.etree.ElementTree as ET
+import posixpath
 
-class DevPIAPI( HttpAPI ):
+
+class DevPIAPI(HttpAPI):
     """
     Class for providing some simple Http requests to PyPI based on DevPI 
     """
-    _env_prefix = "PYPI_PRODUCTION";
+    _env_prefix = "PYPI_PRODUCTION"
 
-    def _split_pkg_string( r_self, str_name ):
+    def _split_pkg_string(self, name):
         """
         Split string for package name into components following PyPI standard
-        :param r_self: self reference
-        :type r_self: DevPIApi object
-        :param str_name: python package name
-        :type str_name: string, unicode
-        :return: dictionary with components: distribution, version, build_tag, python_tag, abi_tag, platform_tag. Some of them may be absent
+        :param str name: python package name
+        :return dict: components: distribution, version, build_tag, python_tag, abi_tag, platform_tag.
+                      Some of them may be absent
         """
 
-        obj_match = re.match( r'^(?P<distribution>[^\.]*)-(?P<version>[\d\.]+)(-(?P<build_tag>[^\-]+))?-(?P<python_tag>[^\-]+)-(?P<abi_tag>[^\-]+)-(?P<platform_tag>[^\-\.]+)\.whl$', str_name );
+        _match = re.match(
+            r'^(?P<distribution>[^\.]*)-(?P<version>[\d\.]+)(-(?P<build_tag>[^\-]+))?-(?P<python_tag>[^\-]+)-(?P<abi_tag>[^\-]+)-(?P<platform_tag>[^\-\.]+)\.whl$', name)
 
-        if obj_match is None:
-            obj_match = re.match( r'^(?P<distribution>[^\.]*)-(?P<version>[\d\.]+)\.tar\.gz$', str_name );
+        if _match is None:
+            _match = re.match(r'^(?P<distribution>[^\.]*)-(?P<version>[\d\.]+)\.tar\.gz$', name)
 
-        if obj_match is None:
-            raise ValueError( 'DevPI answer is wrong: package name ' + str_name + " does not match any known pattern" );
+        if _match is None:
+            raise ValueError('DevPI answer is wrong: package name [%s] does not match any known pattern' % name)
 
-        return obj_match.groupdict();
+        return _match.groupdict()
 
-    def get_package_versions( r_self, str_name ):
+    def get_package_versions(self, name):
         """
         Get package version list from server
-        :param r_self: self reference
-        :type r_self: DevPIApi object
-        :param str_name: python package name
-        :type str_name: string, unicode
+        :param self: self reference
+        :type self: DevPIApi object
+        :param name: python package name
+        :type name: string, unicode
         :return: list of versions on the server, or None if nothing found
         """
 
-        str_name = str_name.strip();
-        str_request = posixpath.join( "+simple", str_name );
-        obj_resp = r_self.get( str_request );
+        name = name.strip()
+        _request = posixpath.join("+simple", name)
+        _resp = self.get(_request)
 
-        if ( obj_resp.status_code != 200 ):
-            return None;
+        if (_resp.status_code != 200):
+            return None
 
-        xml_resp = ET.fromstring( obj_resp.text );
+        xml_resp = ET.fromstring(_resp.text)
 
-        return list( set( [r_self._split_pkg_string( x.text )[ 'version' ] for x in xml_resp.findall( 'body/a' )] ) )
+        return list(set([self._split_pkg_string(x.text)['version'] for x in xml_resp.findall('body/a')]))
```

## oc_cdtapi/DmsAPI.py

```diff
@@ -1,164 +1,230 @@
 import logging
 import os
 import re
+import posixpath
+
+from . import API
 
-from oc_cdtapi import API
 
 class DmsAPIError(API.HttpAPIError):
     pass
 
-class DmsAPI(API.HttpAPI):   # we use HttpAPI as a base class - the idea of HttpAPI is to use it as a skelet for new API clients
+
+# we use HttpAPI as a base class - the idea of HttpAPI is to use it as a skelet for new API clients
+class DmsAPI(API.HttpAPI):   
     """
     DmsAPI implementation
     """
     # do not forget about docstrings
 
-    _env_prefix = 'DMS' # this automatically allows usage of DMS_* environment variables - everything is done in HttpAPI for you
+    # this automatically allows usage of DMS_* environment variables - everything is done in HttpAPI for you
+    _env_prefix = 'DMS'  
     _env_token = '_TOKEN'
-    _env_crs = '_CRS_URL' # now we have a separate Components Registry Service for components info obtaining
+    # for now we have a separate Components Registry Service for components info obtaining
+    # TODO: refactor when it will be joined with base DMS API on the server-side
+    _env_crs = '_CRS_URL'
 
     def __init__(self, *args, **argv):
         """
         Initialiazing the parent class then loading the DMS API's bearer token
         """
-        API.HttpAPI.__init__(self)
+
+        # TODO: re-factor when Python2 support will be deprecated
+        super(DmsAPI, self).__init__(*args, **argv)
         self.crs_root = os.getenv(self._env_prefix + self._env_crs)
         token = os.getenv(self._env_prefix + self._env_token)
+
         if not self.crs_root:
-            raise DmsAPIError("DMS API initialization failed. The components request url is not set")
+            raise DmsAPIError("DMS API initialization failed. The components request URL [%s] is not set" % (
+                self._env_prefix + self._env_crs))
+
         if token:
             self.headers = {"Authorization": "Bearer {}".format(token)}
         else:
-            self.headers = {} # Empty headers dict is added for backwards-compatibility with bearer token functional
+            # Empty headers dict is added for backwards-compatibility with bearer token functional
+            self.headers = {}
+
+    def __req(self, req):
+        """
+        Joining an URL to one posixpath-compatible
+        :param str req: request, may be list of str
+        :return str: joined req
+        """
+        if not req:
+            return req
+
+        if isinstance(req, list):
+            logging.log(5, "re-formatting requested list [%s] URL to string" % ', '.join(req))
+            req = posixpath.sep.join(req)
+
+        return req
 
-        if self.crs_root[-1] != '/': self.crs_root += '/'
 
     def re(self, req):
         """
         Re-defines default request formater, not to be called directly
-        This forms request URL separated by / from string array
+        This forms request URL separated by slash from string array
+        :param req: list of str or str for sub-url
+        :return str: full joined URL
         """
-        if len(req) == 0: return self.root
-        return self.root + 'dms-service/rest/api/' + '/'.join(req)
 
-        # directly accessing class variables outside the class itself is possible, but should be avoided
-        # consider using setters/getters or storing state outside the class
-    
+        if not req:
+            return self.root
+
+        # do not use 'urlparse.urljoin' here because it gives wrong result if 'root'
+        # contains sub-path. Example:
+        # urlparse.urljoin("https://exapmle.com:5400/c1/c2/c3", "c4/c5/c6")
+        # gives 'https://exapmle.com:5400/c1/c2/c4/c5/c6'
+        # while 'https://exapmle.com:5400/c1/c2/c3/c4/c5/c6' expected ('c3' missing)
+
+        return posixpath.join(self.root, "dms-service", "rest", "api", self.__req(req))
+
+    # directly accessing class variables outside the class itself is possible, but should be avoided
+    # consider using setters/getters or storing state outside the class
+
     def crs_re(self, req):
         """
         Forming the correct URL for the DMS Components Registry Service
+        :param req: list of str or str for sub-url
+        :return str: full joined URL
         """
-        if len(req) == 0: return self.crs_root
-        return self.crs_root + 'rest/api/' + '/'.join(req)
+        if not req:
+            return self.crs_root
+
+        # see the note about 'urljoin' in 're' method - the same is applicable here
 
-    def get_artifacts(self, component, version, ctype = None):
+        return posixpath.join(self.crs_root, 'rest', 'api', self.__req(req))
+
+    def get_artifacts(self, component, version, ctype=None):
         """
         Gets list of artifacts of given component, version and type
         :param component: dms component name
         :param version:   dms version name
         :param ctype:     type of artifact. if not specified - query all known types
         :returns:         list of artifacts
         """
-        assert bool(re.match('^[a-zA-Z0-9_-]*$', component)), "Component name must contain only latin letters, numbers, underscores and hyphens"
-        assert bool(re.match('^[a-zA-Z0-9._-]*$', version)), "Version must contain only latin letters, numbers, underscores, hyphens and dots"
+        assert bool(re.match('^[a-zA-Z0-9_-]*$', component)
+                    ), "Component name must contain only latin letters, numbers, underscores and hyphens"
+        assert bool(re.match('^[a-zA-Z0-9._-]*$', version)
+                    ), "Version must contain only latin letters, numbers, underscores, hyphens and dots"
         logging.debug('Reached %s.get_artifacts', self.__class__.__name__)
+
         if ctype is None:
             types = self.get_types()
         else:
-            assert bool(re.match('^[a-zA-Z0-9_-]*$', ctype)), "Component type must contain only latin letters, numbers, underscores and hyphens"
-            types = [ ctype ]
+            assert bool(re.match('^[a-zA-Z0-9_-]*$', ctype)
+                        ), "Component type must contain only latin letters, numbers, underscores and hyphens"
+            types = [ctype]
 
         artifacts = []
 
         for t in types:
             req = ['2', 'component', component, 'version', version, t, 'list']
-            artifacts += self.get(req, headers=self.headers, verify=False).json() # Why do you use write_to parameter instead of just using response object ?
+
+            # Why do you use write_to parameter instead of just using response object ?
             # also, requests has json parser, no need to re-invent it
+            artifacts += self.get(req, headers=self.headers, verify=False).json()
 
-        logging.debug('About to return an array of %d elements', len(artifacts)) # logging has its own format-string engine
-        return artifacts
+        # logging has its own format-string engine
+        logging.debug('About to return an array of %d elements', len(artifacts))
 
+        return artifacts
 
     def get_components(self):
         """
         Gets list of components known to DMS
         :returns: array of components
         """
         logging.debug('Reached %s.get_components', self.__class__.__name__)
         req = ['1', 'components']
 
         crs_request_url = self.crs_re(req)
-        components = self.web.get(crs_request_url, verify=False).json()['components']
+        components = self.web.get(crs_request_url, verify=False).json().get('components', list())
         logging.debug('About to return an array of %d elements', len(components))
+
         return components
 
     def get_gav(self, component, version, ctype, artifact, classifier=None):
         """
         Requests and forms gav for specified artifact
-        :param component: component name
-        :param version: version
-        :param ctype:
-        :param artifact:
-        :param classifier:
-        :returns: gav
-        """
-        assert bool(re.match('^[a-zA-Z0-9_-]+$', component)), "Component name have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
-        assert bool(re.match('^[a-zA-Z0-9\._-]+$', version)), "Version have not to be empty and must contain only latin letters, numbers, underscores, hyphens and dots"
-        assert bool(re.match('^[a-zA-Z0-9_-]+$', ctype)), "Component type have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
-        assert bool(re.match('^[a-zA-Z0-9_-]+$', artifact)), "Artifact type have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
+        :param str component: component name
+        :param str version: version
+        :param str ctype:
+        :param str artifact:
+        :param str classifier:
+        :returns str: gav
+        """
+        assert bool(re.match('^[a-zA-Z0-9_-]+$', component)
+                    ), "Component name have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
+        assert bool(re.match('^[a-zA-Z0-9\._-]+$', version)
+                    ), "Version have not to be empty and must contain only latin letters, numbers, underscores, hyphens and dots"
+        assert bool(re.match('^[a-zA-Z0-9_-]+$', ctype)
+                    ), "Component type have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
+        assert bool(re.match('^[a-zA-Z0-9_-]+$', artifact)
+                    ), "Artifact type have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
         logging.debug('Reached %s.get_gav', self.__class__.__name__)
         logging.debug('component: {0}'.format(component))
         logging.debug('version: {0}'.format(version))
         logging.debug('artifact: {0}'.format(artifact))
         logging.debug('classifier: {0}'.format(classifier))
         req = ['1', 'component', component, 'version', version, ctype, artifact, 'gav']
+
+        params = None
+
         if classifier:
-            assert bool(re.match('^[a-zA-Z0-9_-]+$', classifier)), "Non-empty classifier must contain only latin letters, hyphens and underscores"
+            assert bool(re.match('^[a-zA-Z0-9_-]+$', classifier)
+                        ), "Non-empty classifier must contain only latin letters, hyphens and underscores"
             params = {'classifier': classifier}
-        else:
-            params = None
 
         gav = self.get(req, params, headers=self.headers).json()
 
-        assert bool(re.match('^[a-zA-Z0-9\._-]+$', gav['groupId'])), "groupId have not to be empty and must contain only latin letters, numbers, underscores, hyphens and dots"
-        assert bool(re.match('^[a-zA-Z0-9_-]+$', gav['artifactId'])), "artifactId have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
-        assert bool(re.match('^[a-zA-Z0-9\._-]+$', gav['version'])), "version have not to be empty and must contain only latin letters, numbers, underscores, hyphens and dots"
-        assert bool(re.match('^[a-zA-Z0-9_-]+$', gav['packaging'])), "packaging have not to be empty and must contain only latin letters, hyphens and underscores"
+        assert bool(re.match('^[a-zA-Z0-9\._-]+$', gav['groupId'])
+                    ), "groupId have not to be empty and must contain only latin letters, numbers, underscores, hyphens and dots"
+        assert bool(re.match('^[a-zA-Z0-9_-]+$', gav['artifactId'])
+                    ), "artifactId have not to be empty and must contain only latin letters, numbers, underscores and hyphens"
+        assert bool(re.match('^[a-zA-Z0-9\._-]+$', gav['version'])
+                    ), "version have not to be empty and must contain only latin letters, numbers, underscores, hyphens and dots"
+        assert bool(re.match('^[a-zA-Z0-9_-]+$', gav['packaging'])
+                    ), "packaging have not to be empty and must contain only latin letters, hyphens and underscores"
+
+        _gav = ':'.join(list(map(lambda x: gav[x], ['groupId', 'artifactId', 'version', 'packaging'])))
 
-        _gav = ':'.join( [gav['groupId'], gav['artifactId'], gav['version'], gav['packaging']] )
         if gav.get('classifier'):
-            assert bool(re.match('^[a-zA-Z0-9_-]+$', gav['classifier'])), "non-empty classifier must contain only latin letters, hyphens and underscores"
+            assert bool(re.match('^[a-zA-Z0-9_-]+$', gav['classifier'])
+                        ), "non-empty classifier must contain only latin letters, hyphens and underscores"
             _gav = ':'.join([_gav, gav['classifier']])
 
         logging.debug('Formed gav: %s', _gav)
 
         return _gav
 
-
-    def get_types(self): return ['notes', 'distribution', 'report', 'static', 'documentation']
-
+    def get_types(self): 
+        return ['notes', 'distribution', 'report', 'static', 'documentation']
 
     def get_versions(self, component):
         """
         fetches list of versions for specified component
-        :param component: component name
-        :returns: array of versions
+        :param str component: component name
+        :returns list: versions
         """
-        assert bool(re.match('^[a-zA-Z0-9_-]*$', component)), "Component name must contain only latin letters, numbers, underscores and hyphens"
+
+        assert bool(re.match('^[a-zA-Z0-9_-]*$', component)
+                    ), "Component name must contain only latin letters, numbers, underscores and hyphens"
+
         logging.debug('Reached %s.get_versions', self.__class__.__name__)
 
         req = ['2', 'component', component, 'versions']
 
         versions = list(map(lambda x: x.get('version'), self.get(req, headers=self.headers).json().get('versions')))
-        logging.debug('About to return an array of %d elements',len(versions))
-        return versions
+        logging.debug('About to return an array of %d elements', len(versions))
 
+        return versions
 
     def ping_dms(self):
         """
         sends a request to dms root
         :returns: server response
         """
         logging.debug('Reached %s.ping_dms', self.__class__.__name__)
-        return self.get([], headers=self.headers).content
 
+        return self.get([], headers=self.headers).content
```

## oc_cdtapi/DmsGetverAPI.py

```diff
@@ -1,328 +1,391 @@
-import json, logging, os, re, time
+import json
+import logging
+import time
 
-from oc_cdtapi import API
+from . import API
 import posixpath
 
+
 class DmsGetverAPI (API.HttpAPI):
     # prefix for credentials environment variables used by HttpAPI
     _env_prefix = 'DMS'
 
+    def __init__(self, *args, **argv):
+        logging.debug('Reached __init__')
+        logging.debug('Calling base class constructor for availability of HttpAPI methods')
 
-    def __init__ (self, *args, **argp):
-        logging.debug ('Reached __init__')
-        logging.debug ('Calling base class constructor for availability of HttpAPI methods')
-        super (DmsGetverAPI, self).__init__ (*args, **argp)
+        # TODO: re-factor when Python2 support will be deprecated
+        super(DmsGetverAPI, self).__init__(*args, **argv)
 
         # delivery states in process
         self.waiting_states = ['INITIATED', 'PROCESSING', 'QUEUED']
 
         # delivery states finished
         self.exit_states = ['READY', 'FAILED']
 
         # wait for state timeout
         self.wait_state_timeout = 1000
 
         # wait for state request interval
         self.wait_state_sleep = 30
 
-
-    def create_distr_request (self, version = None, source_version = None, distr_type = None, client_filter = None):
+    def create_distr_request(self, version=None, source_version=None, distr_type=None, client_filter=None):
         """
         Creates a new distribution request
-        :parameter version: required version e.g. 03.44.30.55
-        :parameter distr_type: distribution type e.g. CARDS
-        :parameter client_filter: a set of software components e.g. Diners Club Russia Acquiring;MasterCard;VISA;
+        :param str version: required version e.g. 03.44.30.55
+        :param str distr_type: distribution type e.g. CARDS
+        :param client_filter: a set of software components e.g. Diners Club Russia Acquiring;MasterCard;VISA;
                                   if not provided an attempt to fetch it from svn will be performed
                                   filter fetching is defined in separate class
         :return: distribution state info as returned by dms
         """
-        logging.debug ('Reached create_distr_request')
+        logging.debug('Reached create_distr_request')
 
-        distr_state_info = self._create_distr_request_int (version = version, source_version = source_version, distr_type = distr_type, client_filter = client_filter)
-        return distr_state_info
+        distr_state_info = self._create_distr_request_int(
+            version=version, source_version=source_version, distr_type=distr_type, client_filter=client_filter)
 
+        return distr_state_info
 
-    def get_distr (self, distr_id, distr_option):
+    def get_distr(self, distr_id, distr_option):
         """
         Fetches distribution from dms
-        :parameter distr_id: distribution id
-        :return distr: distribution fetched from dms or None on error
-        :return distr_state_info: distribution info
-        """
-        logging.debug ('Reached get_distr')
-        logging.debug ('Distr id [%s]' % distr_id)
-        logging.debug ('Distr option [%s]' % distr_option)
+        :param str distr_id: distribution id
+        :return tuple(distr, distr_state_info): distribution fetched from dms or None on error, distribution info
+        """
+        logging.debug('Reached get_distr')
+        logging.debug('Distr id [%s]' % distr_id)
+        logging.debug('Distr option [%s]' % distr_option)
         distr = None
-        distr_state_info = self.get_distr_state_info_byid (distr_id, distr_option)
-        if distr_state_info ['state'] != 'READY':
-            logging.debug ('Distribution [%s] is in not ready state [%s]' % (distr_id, distr_state_info ['state'] ) )
+
+        distr_state_info = self.get_distr_state_info_byid(distr_id, distr_option)
+        if distr_state_info['state'] != 'READY':
+            logging.debug('Distribution [%s] is in not ready state [%s]' % (
+                distr_id, distr_state_info['state']))
         else:
-            logging.debug ('Distribution [%s] is in ready state, downloading' % distr_id)
+            logging.debug('Distribution [%s] is in ready state, downloading' % distr_id)
             url = posixpath.join('dms-getver', 'distribution', 'id:%s' % distr_id, 'download')
-            logging.debug ('Getting from [%s]' % url)
-            logging.debug ('Requesting [%s]' % distr_state_info ['fileName'] )
-            distr_resp = self.get (url)
+            logging.debug('Getting from [%s]' % url)
+            logging.debug('Requesting [%s]' % distr_state_info['fileName'])
+            distr_resp = self.get(url)
             if distr_resp.status_code != 200:
-                logging.debug ('DMS returned an error response [%s] while getting [%s]' % (distr_resp.status_code, url) )
+                logging.debug('DMS returned an error response [%s] while getting [%s]' % (
+                    distr_resp.status_code, url))
             else:
                 distr = distr_resp.content
-                logging.debug ('Fetched [%s] bytes from [%s]' % (len (distr), url) )
-        return distr, distr_state_info
+                logging.debug('Fetched [%s] bytes from [%s]' % (len(distr), url))
 
+        return distr, distr_state_info
 
-    def get_distr_state_info (self,  version = None, source_version = None, distr_type = None, client_filter = None):
+    def get_distr_state_info(self,  version=None, source_version=None, distr_type=None, client_filter=None):
         """
         Requests distribution state info from dms
         parameters description see in create_distr_request
         """
-        logging.debug ('Reached get_distr_state_info')
+        logging.debug('Reached get_distr_state_info')
 
-        url, parms = self._get_distr_state_url (version = version, source_version = source_version, distr_type = distr_type, client_filter = client_filter)
-        distr_state_info = self._get_distr_state_info_int (url, parms)
-        return distr_state_info
+        url, parms = self._get_distr_state_url(
+            version=version, source_version=source_version, distr_type=distr_type, client_filter=client_filter)
+        distr_state_info = self._get_distr_state_info_int(url, parms)
 
+        return distr_state_info
 
-    def get_distr_state_info_byid (self, distr_id, distr_option):
+    def get_distr_state_info_byid(self, distr_id, distr_option):
         """
         Requests distribution state info from dms
+        :param str distr_id: distributive ID (digits-as-string)
+        :param str distr_option: additional distributive option
+        :return distr_state_info: distributive state information
         """
-        logging.debug ('Reached get_distr_state_info_byid')
+        logging.debug('Reached get_distr_state_info_byid')
+
         if distr_option == 'full':
-            logging.debug ('Full distr info requested')
+            logging.debug('Full distr info requested')
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution', 'id:%s' % distr_id)
         else:
-            logging.debug ('Diff distr info requested')
+            logging.debug('Diff distr info requested')
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution-difference', 'id:%s' % distr_id)
 
-        distr_state_info = self._get_distr_state_info_int (url)
-        return distr_state_info
+        distr_state_info = self._get_distr_state_info_int(url)
 
+        return distr_state_info
 
-    def get_dms_gav (self, distr_id, distr_option):
+    def get_dms_gav(self, distr_id, distr_option):
         """
         Requests gav by distribution id
-        """
-        logging.debug ('Reached get_dms_gav')
-        logging.debug ('Request for gav for [%s] distr id [%s]' % (distr_option, distr_id) )
+        :param str distr_id: distributive ID (digits-as-string)
+        :param str distr_option: additional distributive option
+        :return str: GAV, or None if not found
+        """
+        logging.debug('Reached get_dms_gav')
+        logging.debug('Request for gav for [%s] distr id [%s]' % (
+            distr_option, distr_id))
+
         if distr_option == 'full':
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution', 'id:%s' % distr_id, 'gav')
         else:
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution-difference', 'id:%s' % distr_id, 'gav')
-        resp = self.get (url)
+
+        resp = self.get(url)
+
         if resp.status_code == 200:
-            logging.debug ('OK response from dms-getver')
-            gav = resp.json ()
-            gav_text = '%s:%s:%s:%s' % (gav ['groupId'], gav ['artifactId'], gav ['version'], gav ['packaging'] )
-            logging.debug ('Returning [%s]' % gav_text)
+            logging.debug('OK response from dms-getver')
+            gav = resp.json()
+            # we have to raise an exception if anything were not returned
+            # it is the cause to rid of 'get' method usage
+            gav_text = ':'.join(list(map(lambda x: gav[x], [
+                'groupId', 'artifactId', 'version', 'packaging'])))
+
+            logging.debug('Returning [%s]' % gav_text)
         else:
-            logging.debug ('Error response [%s] from dms-getver' % resp.status_code)
+            logging.debug('Error response [%s] from dms-getver' % resp.status_code)
             gav_text = None
-            logging.debug ('Returning None')
-        return gav_text
+            logging.debug('Returning None')
 
+        return gav_text
 
-    def get_dms_log (self, distr_id, distr_option):
+    def get_dms_log(self, distr_id, distr_option):
         """
         Retrieve dms log
+        :param str distr_id: distributive ID (digits-as-string)
+        :param str distr_option: additional distributive option
+        :return str: DMS log, or None if no logs found or response error
         """
-        logging.debug ('Reached get_dms_log')
-        logging.debug ('Request for log of processing distr [%s]' % distr_id)
+        logging.debug('Reached get_dms_log')
+        logging.debug('Request for log of processing distr [%s]' % distr_id)
 
-        url = self.get_dms_log_url (distr_id, distr_option)
+        url = self.get_dms_log_url(distr_id, distr_option)
 
         log = None
-        resp = self.get (url)
+        resp = self.get(url)
         status_code = resp.status_code
-        logging.debug ('Response status code: [%s]' % status_code)
+        logging.debug('Response status code: [%s]' % status_code)
 
         if status_code != 200:
-            logging.debug ('Error response from dms')
+            logging.debug('Error response from dms')
         else:
             log = resp.text
 
         return log
 
+    def get_dms_log_url(self, distr_id, distr_option):
+        """
+        Prepare log URL
+        :param str distr_id: distributive ID (digits-as-string)
+        :param str distr_option: additional distributive option
+        :return str: DMS log URL for further requesting
+        """
+        logging.debug('Reached get_dms_log_url')
+        logging.debug('Request for url for [%s] distr [%s]' % (distr_option, distr_id))
 
-    def get_dms_log_url (self, distr_id, distr_option):
-        logging.debug ('Reached get_dms_log_url')
-        logging.debug ('Request for url for [%s] distr [%s]' % (distr_option, distr_id) )
-        if distr_option == 'full':
-            url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution', 'id:%s' % distr_id, 'log')
-        else:
-            url = posixpath.join('dms-getver', 'rest', 'api', 'distribution-difference', 'id:%s' % distr_id, 'log')
-        logging.debug ('url for log request: [%s]' % url)
-        return url
+        url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution%s' % (
+            "-difference" if distr_option != "full" else ""), 'id:%s' % distr_id, 'log')
 
+        logging.debug('url for log request: [%s]' % url)
 
-    def wait_for_state (self, distr_id, distr_option):
+        return url
+
+    def wait_for_state(self, distr_id, distr_option):
         """
         Wait until either distr gets into an exit state or a timeout occurs
         States and timeouts are defined in __init__
+        :param str distr_id: distributive ID (digits-as-string)
+        :param str distr_option: additional distributive option
+        :return distr_state_info: distributive information after wait
         """
-        logging.debug ('Reached wait_for_state')
+        logging.debug('Reached wait_for_state')
         ela = 0
-        st = int (time.time () )
+        st = int(time.time())
         distr_state_info = {}
-        distr_state_info ['state'] = 'TIMEOUT'
-        while ela < int (self.wait_state_timeout):
-            ela = int (time.time () ) - st
-            dsi = self.get_distr_state_info_byid (distr_id, distr_option)
-            state = dsi ['state']
+        distr_state_info['state'] = 'TIMEOUT'
+
+        while ela < self.wait_state_timeout:
+            ela = int(time.time()) - st
+            dsi = self.get_distr_state_info_byid(distr_id, distr_option)
+            state = dsi['state']
+
             if not state in self.waiting_states:
-                logging.debug ('Distr [%s] is in exit state [%s]' % (distr_id, state) )
+                logging.debug('Distr [%s] is in exit state [%s]' % (distr_id, state))
                 distr_state_info = dsi
                 break
-            logging.debug ('Distr [%s] is in waiting state [%s]' % (distr_id, state) )
-            logging.debug ('Retrying in [%s] sec., [%s] of [%s] sec. in wait' % (self.wait_state_sleep, ela, self.wait_state_timeout) )
-            time.sleep (self.wait_state_sleep)
-        return distr_state_info
 
+            logging.debug('Distr [%s] is in waiting state [%s]' % (distr_id, state))
+            logging.debug('Retrying in [%s] sec., [%s] of [%s] sec. in wait' % (
+                self.wait_state_sleep, ela, self.wait_state_timeout))
+
+            time.sleep(self.wait_state_sleep)
 
-    def _create_distr_request_int (self, version = None, source_version = None, distr_type = None, client_filter = None):
+        return distr_state_info
+
+    def _create_distr_request_int(self, version=None, source_version=None, distr_type=None, client_filter=None):
         """
         Creates a new distribution request
+        :param str versoin: version required
+        :param str source_version: source version for diff-type distributives
+        :param str distr_type: type of distributive requested
+        :param client_filter: components to filter, may be empty
+        :return distr_state_info: or None on error
         """
-        logging.debug ('Reached _create_distr_request_int')
-        logging.debug ('version = [%s]' % version)
-        logging.debug ('source_version = [%s]' % source_version)
-        logging.debug ('distr_type = [%s]' % distr_type)
+
+        logging.debug('Reached _create_distr_request_int')
+        logging.debug('version = [%s]' % version)
+        logging.debug('source_version = [%s]' % source_version)
+        logging.debug('distr_type = [%s]' % distr_type)
+
         if client_filter:
-            logging.debug ('client_filter length = [%s]' % len (client_filter) )
+            logging.debug('client_filter length = [%s]' % len(client_filter))
         else:
-            logging.debug ('Filters not specified')
+            logging.debug('Filters not specified')
             client_filter = ''
 
         distr_state_info = {}
         req_parm = {}
-        req_parm ['product'] = distr_type
+        req_parm['product'] = distr_type
 
         if source_version:
-            logging.debug ('Diff distribution requested')
+            logging.debug('Diff distribution requested')
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution-difference')
-            req_parm ['initialVersion'] = source_version
-            req_parm ['targetVersion'] = version
-            req_parm ['initialFilters'] = client_filter
-            req_parm ['targetFilters'] = client_filter
+            req_parm['initialVersion'] = source_version
+            req_parm['targetVersion'] = version
+            req_parm['initialFilters'] = client_filter
+            req_parm['targetFilters'] = client_filter
         else:
-            logging.debug ('Full distribution requested')
+            logging.debug('Full distribution requested')
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution')
-            req_parm ['version'] = version
-            req_parm ['filter'] = client_filter
+            req_parm['version'] = version
+            req_parm['filter'] = client_filter
 
-        logging.debug ('request parameters: [%s]' % json.dumps (req_parm, indent = 4) )
-        resp = self.post (url, json = req_parm)
+        logging.debug('request parameters: [%s]' % json.dumps(req_parm, indent=4))
+        resp = self.post(url, json=req_parm)
 
         # we shold have been expecting 202 here, but it's 200 somehow
         if resp.status_code != 200:
-            logging.debug ('DMS responds with unexpected status code [%s]' % resp.status_code)
-            logging.debug ('DMS response body: %s' % resp.text)
-            distr_state_info ['id'] = None
-            distr_state_info ['state'] = 'HTTP/%s' % resp.status_code
+            logging.debug('DMS responds with unexpected status code [%s]' % resp.status_code)
+            logging.debug('DMS response body: %s' % resp.text)
+            distr_state_info['id'] = None
+            distr_state_info['state'] = 'HTTP/%s' % resp.status_code
         else:
-            distr_state_info = resp.json ()
+            distr_state_info = resp.json()
 
-        distr_state = distr_state_info ['state']
-        distr_id = distr_state_info ['id']
+        distr_state = distr_state_info['state']
+        distr_id = distr_state_info['id']
 
         if distr_state and distr_id:
-            logging.debug ('Created dist id [%s] in state [%s]' % (distr_id, distr_state) )
-            distr_state_info = self._normalize_dsi (distr_state_info)
+            logging.debug('Created dist id [%s] in state [%s]' % (distr_id, distr_state))
+            distr_state_info = self._normalize_dsi(distr_state_info)
 
         return distr_state_info
 
-
-    def _dumb_404 (self, resp):
+    def _dumb_404(self, resp):
         """
         This is to distinguish a server 404 from an application 404 (which should have been 200)
+        :param resp: response to check
+        :return bool: do we have to return 404 or not
         """
-        logging.debug ('Reached _dumb_404')
+        logging.debug('Reached _dumb_404')
+
         try:
-            j = resp.json ()
+            j = resp.json()
         except ValueError as e:
-            logging.debug ('Failed to get json from dms response, returning False')
+            logging.debug('Failed to get json from dms response, returning False')
             return False
-        if j ['code'] == 'DMS-GETVER-40001':
-            logging.debug ('Found a "dms not found" response code, returning True')
+
+        if j.get('code') == 'DMS-GETVER-40001':
+            logging.debug('Found a "dms not found" response code, returning True')
             return True
-        else:
-            logging.debug ('Json response processed, but no "dms not found" code detected, returning False')
-            return False
 
+        logging.debug('Json response processed, but no "dms not found" code detected, returning False')
+        return False
 
-    def _get_distr_state_info_int (self, url, parms=None):
+    def _get_distr_state_info_int(self, url, parms=None):
         """
         Requests and returns distr state
         states known so far: INITIATED, PROCESSING, FAILED, READY. + 
         NOTFOUND set by this method upon http/404 and TIMEOUT set by wait_for_state
+        :param str url: URL to request
+        :param dict params: additional request parameters
+        :return requests.Response: 
         """
-        logging.debug ('Reached _get_distr_state_info_int')
-        logging.debug ('URL = [%s]' % url)
+        logging.debug('Reached _get_distr_state_info_int')
+        logging.debug('URL = [%s]' % url)
 
         try:
-            if 'search' in url:
-                logging.debug ('[search] endpoint, assuming POST')
-                resp = self.post (url, json = parms)
+            # TODO: refactor to get rid of this everystic fork if possible
+            # when new version of DMS API will be implemented
+            if 'search' in url.split(posixpath.sep):
+                logging.debug('[search] endpoint, assuming POST')
+                resp = self.post(url, json=parms)
             else:
-                logging.debug ('not a [search] endpoint, assuming GET')
-                resp = self.get (url, params = parms)
+                logging.debug('not a [search] endpoint, assuming GET')
+                resp = self.get(url, params=parms)
         except API.HttpAPIError as e:
             resp = e.resp
 
         distr_state_info = {}
 
         # bad status
         if resp.status_code != 200:
-            logging.debug ('DMS reponds with status code [%s]' % resp.status_code)
-            if resp.status_code == 404 and self._dumb_404 (resp):
-                distr_state_info ['state'] = 'NOTFOUND'
-                distr_state_info ['id'] = None
+            logging.debug('DMS reponds with status code [%s]' % resp.status_code)
+
+            if resp.status_code == 404 and self._dumb_404(resp):
+                distr_state_info['state'] = 'NOTFOUND'
+                distr_state_info['id'] = None
             else:
-                distr_state_info ['state'] = 'HTTP/%s' % resp.status_code
-                distr_state_info ['id'] = None
+                distr_state_info['state'] = 'HTTP/%s' % resp.status_code
+                distr_state_info['id'] = None
+
         # ok status
         else:
-            distr_state_info = resp.json ()
+            distr_state_info = resp.json()
 
-        distr_id = distr_state_info ['id']
-        distr_state = distr_state_info ['state']
+        distr_id = distr_state_info['id']
+        distr_state = distr_state_info['state']
 
         if distr_state and distr_id:
-            distr_state_info = self._normalize_dsi (distr_state_info)
-            logging.debug ('Found dist id [%s] in state [%s]' % (distr_id, distr_state) )
+            distr_state_info = self._normalize_dsi(distr_state_info)
+            logging.debug('Found dist id [%s] in state [%s]' % (distr_id, distr_state))
 
         return distr_state_info
 
-
-    def _get_distr_state_url (self, version, source_version = None, distr_type = None, client_filter = None):
+    def _get_distr_state_url(self, version, source_version=None, distr_type=None, client_filter=None):
         """
         forms an url to be used to get distr state info or request new distribution
+        :param str versoin: version required
+        :param str source_version: source version for diff-type distributives
+        :param str distr_type: type of distributive requested
+        :param client_filter: components to filter, may be empty
+        :return tuple(str, dict): URL for further request, parameters for the request
         """
-        logging.debug ('Reached _get_distr_state_url')
-        logging.debug ('Request for url version [%s], type [%s], src_ver [%s]' % (version, distr_type, source_version) )
+        logging.debug('Reached _get_distr_state_url')
+        logging.debug('Request for url version [%s], type [%s], src_ver [%s]' % (version, distr_type, source_version))
 
         if source_version:
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution-difference')
-            parms = {'initialFilters': client_filter, 'initialVersion': source_version, 'product': distr_type, 'targetFilters': client_filter, 'targetVersion': version}
+            parms = {'initialFilters': client_filter, 'initialVersion': source_version,
+                     'product': distr_type, 'targetFilters': client_filter, 'targetVersion': version}
         else:
             url = posixpath.join('dms-getver', 'rest', 'api', '1', 'distribution', 'search')
             parms = {'filter': client_filter, 'product': distr_type, 'version': version}
-        logging.debug ('URL=[%s]' % url)
-        return url, parms
 
+        logging.debug('URL=[%s]' % url)
+
+        return url, parms
 
-    def _normalize_dsi (self, distr_state_info):
+    def _normalize_dsi(self, distr_state_info):
         """
         Normalize scattered output from different endpoints
+        :param dict distr_state_info: distributive state information
+        :return dict: normalized distr_state_info
         """
-        logging.debug ('Reached _normalize_dsi')
 
-        if 'initialFilters' in distr_state_info.keys ():
-            logging.debug ('Diff distribution meta-info detected, add distOption=diff, filter, version')
-            distr_state_info ['distOption'] = 'diff'
-            distr_state_info ['filter'] = distr_state_info ['targetFilters']
-            distr_state_info ['version'] = distr_state_info ['targetVersion']
+        logging.debug('Reached _normalize_dsi')
+
+        if 'initialFilters' in distr_state_info.keys():
+            logging.debug('Diff distribution meta-info detected, add distOption=diff, filter, version')
+            distr_state_info['distOption'] = 'diff'
+            distr_state_info['filter'] = distr_state_info['targetFilters']
+            distr_state_info['version'] = distr_state_info['targetVersion']
         else:
-            logging.debug ('Full distribution meta-info detected, only add distOption=full')
-            distr_state_info ['distOption'] = 'full'
-        return distr_state_info
+            logging.debug('Full distribution meta-info detected, only add distOption=full')
+            distr_state_info['distOption'] = 'full'
 
+        return distr_state_info
```

## oc_cdtapi/ForemanAPI.py

```diff
@@ -5,22 +5,18 @@
 import re
 import sys
 
 from oc_cdtapi.API import HttpAPI, HttpAPIError
 from collections import namedtuple, defaultdict
 from datetime import datetime, timedelta
 
-if sys.version_info.major == 3:
-    from urllib.parse import urljoin
-else:
-    from urlparse import urljoin
-
 class ForemanAPIError(HttpAPIError):
     pass
 
+
 class ForemanAPI(HttpAPI):
     """
     A simple client for Foreman's REST API
     """
 
     _error = ForemanAPIError
     _env_prefix = "FOREMAN"
@@ -33,189 +29,181 @@
         """
         HttpAPI.__init__(self)
         class_defaults = namedtuple("values", "exp_date location_id hostgroup deploy_on")
         exp_date = self._set_expiration()
         location_id = 5
         hostgroup = 11
         deploy_on = 1
-
+        self.apiversion = int(os.getenv('FOREMAN_API_VERSION', "1") or "1")
         self.defs = class_defaults(exp_date, location_id, hostgroup, deploy_on)
 
-        if os.environ.get ('FOREMAN_API_VERSION'):
-            self.apiversion = int (os.environ.get ('FOREMAN_API_VERSION') )
-        else:
-            self.apiversion = 1
 
-    
     def re(self, req):
-        return urljoin (self.root, posixpath.join ("api", req) )
+        return posixpath.join(self.root, "api", req)
 
-
-    def get_environment (self, env_name):
+    def get_environment(self, env_name):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_environment')
-        logging.debug ('env_name = [%s]' % env_name)
+        logging.debug('Reached get_environment')
+        logging.debug('env_name = [%s]' % env_name)
         if self.apiversion == 1:
-            logging.error ('Not supported in v1, returning None')
+            logging.error('Not supported in v1, returning None')
             return None
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_environment_v2')
-            return self.get_environment_v2 (env_name)
-
+            logging.debug('Passing to get_environment_v2')
+            return self.get_environment_v2(env_name)
 
-    def get_environment_v2 (self, env_name):
+    def get_environment_v2(self, env_name):
         """
         returns environment id for env_name
         """
-        logging.debug ('Reached get_environment_v2')
-        logging.debug ('env_name = [%s]' % env_name)
+        logging.debug('Reached get_environment_v2')
+        logging.debug('env_name = [%s]' % env_name)
         params = {'search': 'name=%s' % env_name}
-        response = self.get ('environments', params=params).json ()
-        results = response.get ('results')
+        response = self.get('environments', params=params).json()
+        results = response.get('results')
         for result in results:
-            if result.get ('name') == env_name:
-                env_id = result.get ('id')
-                logging.debug ('Found environment [%s]' % env_id)
-                return env_id
-        logging.error ('Could not find environment for [%s], returning None' % env_name)
-        return None
+            if result.get('name') != env_name:
+                continue
 
+            env_id = result.get('id')
+            logging.debug('Found environment [%s]' % env_id)
+            return env_id
 
-    def get_owner (self, user_login):
+        logging.error('Could not find environment for [%s], returning None' % env_name)
+        return None
+
+    def get_owner(self, user_login):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_owner')
+        logging.debug('Reached get_owner')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_owner_v1')
-            return self.get_owner_v1 (user_login)
+            logging.debug('Passing to get_owner_v1')
+            return self.get_owner_v1(user_login)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_owner_v2')
-            return self.get_owner_v2 (user_login)
-
+            logging.debug('Passing to get_owner_v2')
+            return self.get_owner_v2(user_login)
 
-    def get_owner_v1 (self, user_login):
+    def get_owner_v1(self, user_login):
         """
         Looks for user id in the Foreman DB
         """
-        logging.debug ('Reached get_owner_v1')
+        logging.debug('Reached get_owner_v1')
         try:
             params = {'search': 'login=%s' % user_login}
             response = self.get('users', params=params)
         except ForemanAPIError as err:
-            raise(err)
+            raise (err)
 
         data = json.loads(response.text)
 
         try:
             user_id = data["results"][0]["id"]
         except IndexError:
             user_id = None
 
         return user_id
 
-
-    def get_owner_v2 (self, user_login):
+    def get_owner_v2(self, user_login):
         """
         did not change since v1
         """
-        logging.debug ('Reached get_owner_v2')
-        logging.debug ('Passing to get_owner_v1')
-        return self.get_owner_v1 (user_login)
-
+        logging.debug('Reached get_owner_v2')
+        logging.debug('Passing to get_owner_v1')
+        return self.get_owner_v1(user_login)
 
-    def get_usergroup_id (self, group_name):
+    def get_usergroup_id(self, group_name):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_usergroup_id')
+        logging.debug('Reached get_usergroup_id')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_usergroup_id_v1')
-            return self.get_usergroup_id_v1 (group_name)
+            logging.debug('Passing to get_usergroup_id_v1')
+            return self.get_usergroup_id_v1(group_name)
         if self.apiversion == 2:
-            logging.debug ('Passing to get_usergroup_id_v2')
-            return self.get_usergroup_id_v2 (group_name)
+            logging.debug('Passing to get_usergroup_id_v2')
+            return self.get_usergroup_id_v2(group_name)
 
-
-    def get_usergroup_id_v1 (self, group_name):
+    def get_usergroup_id_v1(self, group_name):
         """
         Looks for usergroup id in the Foreman DB
         """
-        logging.debug ('Reached get_usergroup_id_v1')
+        logging.debug('Reached get_usergroup_id_v1')
         if re.search("\s", group_name):
             group_name = "%22{}%22".format(re.sub("\s", "%20", group_name))
-        try:
-            params = {'search': 'name=%s' % group_name}
-            response = self.get('usergroups', params=params)
-        except ForemanAPIError as err:
-            raise(err)
+
+        # removed catching error since it is raised again
+        params = {'search': 'name=%s' % group_name}
+        response = self.get('usergroups', params=params)
 
         data = response.json()
-        
+
         try:
             group_id = data["results"][0]["id"]
         except IndexError:
             group_id = None
 
         return group_id
 
-
-    def get_usergroup_id_v2 (self, group_name):
+    def get_usergroup_id_v2(self, group_name):
         """
         Looks for usergroup id in the Foreman DB
         """
-        logging.debug ('Reached get_usergroup_id_v2')
-        logging.debug ('Passing to get_usergroup_id_v1')
-        return self.get_usergroup_id_v1 (group_name)
-
+        logging.debug('Reached get_usergroup_id_v2')
+        logging.debug('Passing to get_usergroup_id_v1')
+        return self.get_usergroup_id_v1(group_name)
 
     def _set_expiration(self):
         """
-        A private method which sets the default expiration date (1 year from the current date)
+        A private method which sets the default expiration date (3 months from the current date)
         """
-        logging.debug ('Reached _set_expiration')
+        logging.debug('Reached _set_expiration')
         return str((datetime.now() + timedelta(days=90)).strftime('%d/%m/%Y'))
 
-
-    def create_host (self, hostname = None, cores = 1, memory = 4096, disk = 50, owner_id = None,
-                    exp_date = None, location_id = None, hostgroup = None,
-                    deploy_on = None, custom_json = None):
+    def create_host(self, hostname=None, cores=1, memory=4096, disk=50, owner_id=None,
+                    exp_date=None, location_id=None, hostgroup=None,
+                    deploy_on=None, custom_json=None):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached create_host')
-        logging.debug ('hostname = [%s]' % hostname)
-        logging.debug ('cores = [%s]' % cores)
-        logging.debug ('memory = [%s]' % memory)
+        logging.debug('Reached create_host')
+        logging.debug('hostname = [%s]' % hostname)
+        logging.debug('cores = [%s]' % cores)
+        logging.debug('memory = [%s]' % memory)
+
         if self.apiversion == 1:
-            logging.debug ('Passing to create_host_v1')
-            self.create_host_v1 (hostname, cores, memory, disk, owner_id,
-                    exp_date, location_id, hostgroup,
-                    deploy_on, custom_json)
+            logging.debug('Passing to create_host_v1')
+            self.create_host_v1(hostname, cores, memory, disk, owner_id,
+                                exp_date, location_id, hostgroup,
+                                deploy_on, custom_json)
         elif self.apiversion == 2:
-            logging.debug ('Passing to create_host_v2')
-            self.create_host_v2 (hostname, custom_json)
-
+            logging.debug('Passing to create_host_v2')
+            self.create_host_v2(hostname, custom_json)
 
-    def create_host_v1 (self, hostname, cores, memory, disk, owner_id,
-                    exp_date, location_id, hostgroup,
-                    deploy_on, custom_json):
+    def create_host_v1(self, hostname, cores, memory, disk, owner_id,
+                       exp_date, location_id, hostgroup,
+                       deploy_on, custom_json):
         """
         Creates a host using the default parameters or the ones from an external json
-        note that create_vm in engine actually sends db_task instead of hostname and custom_json, other parms are ignored
+        note that create_vm in engine actually sends db_task instead of hostname and custom_json, 
+        other parms are ignored
         """
-        logging.debug ('Reached create_host_v1')
-        logging.debug ('hostname = [%s]' % hostname)
+        logging.debug('Reached create_host_v1')
+        logging.debug('hostname = [%s]' % hostname)
 
-        if not exp_date: exp_date = self.defs.exp_date
-        if not location_id: location_id = self.defs.location_id
-        if not hostgroup: hostgroup = self.defs.hostgroup
-        if not deploy_on: deploy_on = self.defs.deploy_on
+        if not exp_date:
+            exp_date = self.defs.exp_date
+        if not location_id:
+            location_id = self.defs.location_id
+        if not hostgroup:
+            hostgroup = self.defs.hostgroup
+        if not deploy_on:
+            deploy_on = self.defs.deploy_on
 
         default_params = {
             "name": hostname,
             "compute_attributes": {
                 "start": "1",
                 "cpus": cores,
                 "memory_mb": memory,
@@ -239,37 +227,36 @@
 
         if not default_params["is_owned_by"]:
             raise ForemanAPIError("The owner id is not specified")
 
         if not default_params["name"]:
             raise ForemanAPIError("The hostname is not specified")
 
-        logging.debug ("ForemanAPI is about to send the following payload:")
-        logging.debug (default_params)
-        request = self.post("hosts", headers = self.headers, json = default_params)
-
-
-    def create_host_v2 (self, task, custom_json):
-
-        logging.debug ('Reached create_host_v2')
-        logging.debug ('task = [%s]' % task)
-        hostname = task ['task_content'] ['resources'] ['name']
+        logging.debug("ForemanAPI is about to send the following payload:")
+        logging.debug(default_params)
+        request = self.post("hosts", headers=self.headers, json=default_params)
+
+    def create_host_v2(self, task, custom_json):
+
+        logging.debug('Reached create_host_v2')
+        logging.debug('task = [%s]' % task)
+        hostname = task['task_content']['resources']['name']
         cores = 1
         memory = 4096
         disk = 50
         owner_id = None
 
         exp_date = self.defs.exp_date
         location_id = self.defs.location_id
         hostgroup = self.defs.hostgroup
         deploy_on = self.defs.deploy_on
-        domain_id = self.get_domain_id (hostname)
-        arch_id = self.get_architecture_id ('x86_64')
-        os_id = self.get_os_id ('CentOS Linux 7.9.2009')
-        ptable_id = self.get_ptable_id (os_id, 'CDT LVM')
+        domain_id = self.get_domain_id(hostname)
+        arch_id = self.get_architecture_id('x86_64')
+        os_id = self.get_os_id('CentOS Linux 7.9.2009')
+        ptable_id = self.get_ptable_id(os_id, 'CDT LVM')
 
         default_params = {
             "name": hostname,
             "compute_attributes": {
                 "start": "1",
                 "cpus": cores,
                 "memory_mb": memory,
@@ -297,869 +284,831 @@
 
         if not default_params["is_owned_by"]:
             raise ForemanAPIError("The owner id is not specified")
 
         if not default_params["name"]:
             raise ForemanAPIError("The hostname is not specified")
 
-        if not default_params.get ('hostgroup_id'):
-            hostgroup = self.get_hostgroup_id ('stands')
-            logging.debug ('houstgroup_id is not set, setting default [%s]' % hostgroup)
-            default_params ['hostgroup_id'] = hostgroup
-
-        if not default_params.get ('environment_id'):
-            env_id = self.get_environment ('development')
-            logging.debug ('environment_id is not set, setting default [%s]' % env_id)
-            default_params ['environment_id'] = env_id
+        if not default_params.get('hostgroup_id'):
+            hostgroup = self.get_hostgroup_id('stands')
+            logging.debug('houstgroup_id is not set, setting default [%s]' % hostgroup)
+            default_params['hostgroup_id'] = hostgroup
 
-        logging.debug ("ForemanAPI is about to send the following payload:")
-        logging.debug (default_params)
-        request = self.post("hosts", headers = self.headers, json = default_params)
+        if not default_params.get('environment_id'):
+            env_id = self.get_environment('development')
+            logging.debug('environment_id is not set, setting default [%s]' % env_id)
+            default_params['environment_id'] = env_id
 
+        logging.debug("ForemanAPI is about to send the following payload:")
+        logging.debug(default_params)
+        request = self.post("hosts", headers=self.headers, json=default_params)
 
-    def get_architecture_id (self, arch_name):
+    def get_architecture_id(self, arch_name):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_architecture_id')
-        logging.debug ('arch_name = [%s]')
+        logging.debug('Reached get_architecture_id')
+        logging.debug('arch_name = [%s]')
         if self.apiversion == 1:
-            logging.error ('Not supported in v1, returning None')
+            # message appneded since different logging level on above and here
+            logging.error('Get_Architecture_ID is not supported in v1, returning None')
             return None
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_architecture_id_v2')
-            return self.get_architecture_id_v2 (arch_name)
+            logging.debug('Passing to get_architecture_id_v2')
+            return self.get_architecture_id_v2(arch_name)
 
-
-    def get_architecture_id_v2 (self, arch_name):
+    def get_architecture_id_v2(self, arch_name):
         """
         returns architecture id
         """
-        logging.debug ('Reached get_architecture_id_v2')
-        logging.debug ('arch_name = [%s]' % arch_name)
+        logging.debug('Reached get_architecture_id_v2')
+        logging.debug('arch_name = [%s]' % arch_name)
         params = {'search': 'name=%s' % arch_name}
-        response = self.get ('architectures', params=params).json ()
-        logging.debug ('Received response:')
-        logging.debug (response)
-        results = response.get ('results')
+        response = self.get('architectures', params=params).json()
+        logging.debug('Received response: %s')
+        logging.debug(response)
+        results = response.get('results')
+
         for result in results:
-            if result.get ('name') == arch_name:
-                arch_id = result.get ('id')
-                logging.debug ('Found architecture, id = [%s]' % id)
-                return arch_id
-        logging.error ('No architecture found, returning None')
+            if result.get('name') != arch_name:
+                continue
+
+            arch_id = result.get('id')
+            logging.debug('Found architecture, id = [%s]' % id)
+            return arch_id
+
+        logging.error('No architecture found, returning None')
         return None
-      
 
-    def get_domain_id (self, hostname):
+    def get_domain_id(self, hostname):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_domain_id')
+        logging.debug('Reached get_domain_id')
+
         if self.apiversion == 1:
-            logging.error ('Not supported in v1, returning None')
+            logging.error('Not supported in v1, returning None')
             return None
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_domain_id_v2')
-            return self.get_domain_id_v2 (hostname)
+            logging.debug('Passing to get_domain_id_v2')
+            return self.get_domain_id_v2(hostname)
 
-
-    def get_domain_id_v2 (self, hostname):
+    def get_domain_id_v2(self, hostname):
         """
         Returns domain id if found
         """
-        logging.debug ('Reached get_domain_id_v2')
-        logging.debug ('hostname = [%s]' % hostname)
-        domain = '.'.join (hostname.split ('.') [1:] )
-        response = self.get ('domains/')
-        j = response.json ()
-        domains = j ['results']
-        logging.debug ('Searching domain [%s]' % domain)
-        logging.debug ('Domains list:')
-        logging.debug (domains)
+        logging.debug('Reached get_domain_id_v2')
+        logging.debug('hostname = [%s]' % hostname)
+        domain = '.'.join(hostname.split('.')[1:])
+        response = self.get('domains')
+        j = response.json()
+        domains = j['results']
+        logging.debug('Searching domain [%s]' % domain)
+        logging.debug('Domains list:')
+        logging.debug(domains)
+
         for d in domains:
-            if d.get ('name') == domain:
-                return d.get ('id')
-        logging.error ('Cannot find domain for host [%s]' % hostname)
-        return None
+            if d.get('name') == domain:
+                return d.get('id')
 
+        logging.error('Cannot find domain for host [%s]' % hostname)
+        return None
 
-    def get_host_info (self, hostname):
+    def get_host_info(self, hostname):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_host_info')
+        logging.debug('Reached get_host_info')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_host_info_v1')
-            return self.get_host_info_v1 (hostname)
+            logging.debug('Passing to get_host_info_v1')
+            return self.get_host_info_v1(hostname)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_host_info_v2')
-            return self.get_host_info_v2 (hostname)
+            logging.debug('Passing to get_host_info_v2')
+            return self.get_host_info_v2(hostname)
 
-
-    def get_host_info_v1 (self, hostname):
+    def get_host_info_v1(self, hostname):
         """
         Gathers all information about the host and returns it as a json
         """
-        logging.debug ('Reached get_host_info_v1')
-        logging.debug ('hostname = [%s]' % hostname)
-        response = self.get("hosts/" + hostname)
+        logging.debug('Reached get_host_info_v1')
+        logging.debug('hostname = [%s]' % hostname)
+        response = self.get(posixpath.join("hosts", hostname))
         return response.json()
 
+    def get_host_info_v2(self, hostname):
+        logging.debug('Reached get_host_info_v2')
+        logging.debug('hostname = [%s]' % hostname)
+        logging.debug('passing to get_host_info_v1')
+        return self.get_host_info_v1(hostname)
 
-    def get_host_info_v2 (self, hostname):
-        logging.debug ('Reached get_host_info_v2')
-        logging.debug ('hostname = [%s]' % hostname)
-        logging.debug ('passing to get_host_info_v1')
-        return self.get_host_info_v1 (hostname)
-
-
-    def get_ptable_id (self, os_id, ptable_name):
+    def get_ptable_id(self, os_id, ptable_name):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_ptable_id')
+        logging.debug('Reached get_ptable_id')
         if self.apiversion == 1:
-            logging.error ('Not supported in v1, returning None')
+            logging.error('Get_Ptable_Id is not supported in v1, returning None')
             return None
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_ptable_id_v2')
-            return self.get_ptable_id_v2 (os_id, ptable_name)
-
+            logging.debug('Passing to get_ptable_id_v2')
+            return self.get_ptable_id_v2(os_id, ptable_name)
 
-    def get_ptable_id_v2 (self, os_id, ptable_name):
+    def get_ptable_id_v2(self, os_id, ptable_name):
         """
         returns partition table id
         """
-        logging.debug ('Reached get_ptable_id_v2')
-        logging.debug ('os_id = [%s]' % os_id )
-        logging.debug ('ptable_name = [%s]' % ptable_name)
-        response = self.get ('operatingsystems/%s/ptables' % os_id).json ()
-        logging.debug ('response is:')
-        logging.debug (response)
-        results = response.get ('results')
+        logging.debug('Reached get_ptable_id_v2')
+        logging.debug('os_id = [%s]' % os_id)
+        logging.debug('ptable_name = [%s]' % ptable_name)
+        response = self.get(posixpath.join('operatingsystems', str(os_id), 'ptables')).json()
+        logging.debug('response is:')
+        logging.debug(response)
+        results = response.get('results')
         for result in results:
-            if result.get ('name') == ptable_name:
-                ptable_id = result.get ('id')
-                logging.debug ('Found ptable id = [%s]' % ptable_id)
-                return ptable_id
-        logging.error ('No ptable found, returning None')
-        return None
+            if result.get('name') != ptable_name:
+                continue
 
+            ptable_id = result.get('id')
+            logging.debug('Found ptable id = [%s]' % ptable_id)
+            return ptable_id
 
-    def update_host (self, hostname, payload):
+        logging.error('No ptable found, returning None')
+        return None
+
+    def update_host(self, hostname, payload):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached update_host')
+        logging.debug('Reached update_host')
         if self.apiversion == 1:
-            logging.debug ('Passing to update_host_v1')
-            self.update_host_v1 (hostname, payload)
+            logging.debug('Passing to update_host_v1')
+            self.update_host_v1(hostname, payload)
         elif self.apiversion == 2:
-            logging.debug ('Passing to update_host_v2')
-            self.update_host_v2 (hostname, payload)
-
+            logging.debug('Passing to update_host_v2')
+            self.update_host_v2(hostname, payload)
 
-    def update_host_v1 (self, hostname, payload):
+    def update_host_v1(self, hostname, payload):
         """
         Updates the host using the payload
         """
-        logging.debug ('Reached update_host_v1')
-        request = self.put("hosts/" + hostname, headers = self.headers, json = payload)
-
+        logging.debug('Reached update_host_v1')
+        request = self.put(posixpath.join("hosts", hostname), headers=self.headers, json=payload)
 
-    def update_host_v2 (self, hostname, payload):
+    def update_host_v2(self, hostname, payload):
         """
         Updates the host using the payload
         """
-        logging.debug ('Reached update_host_v2')
-        logging.debug ('Passing to update_host_v1')
-        self.update_host_v1 (hostname, payload)
+        logging.debug('Reached update_host_v2')
+        logging.debug('Passing to update_host_v1')
+        self.update_host_v1(hostname, payload)
 
-
-    def delete_host (self, hostname):
+    def delete_host(self, hostname):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached delete_host')
+        logging.debug('Reached delete_host')
         if self.apiversion == 1:
-            logging.debug ('Passing to delete_host_v1')
-            self.delete_host_v1 (hostname)
+            logging.debug('Passing to delete_host_v1')
+            self.delete_host_v1(hostname)
         elif self.apiversion == 2:
-            logging.debug ('Passing to delete_host_v2')
-            self.delete_host_v2 (hostname)
-
+            logging.debug('Passing to delete_host_v2')
+            self.delete_host_v2(hostname)
 
-    def delete_host_v1 (self, hostname):
+    def delete_host_v1(self, hostname):
         """
         Deletes the specified host
         """
-        logging.debug ('Reached delete_host_v1')
-        request = self.delete("hosts/" + hostname, headers = self.headers)
+        logging.debug('Reached delete_host_v1')
+        request = self.delete(posixpath.join("hosts", hostname), headers=self.headers)
 
-
-    def delete_host_v2 (self, hostname):
+    def delete_host_v2(self, hostname):
         """
         Deletes the specified host
         """
-        logging.debug ('Reached delete_host_v2')
-        logging.debug ('Passing to delete_host_v1')
-        self.delete_host_v1 (hostname)
-
+        logging.debug('Reached delete_host_v2')
+        logging.debug('Passing to delete_host_v1')
+        self.delete_host_v1(hostname)
 
-    def puppet_class_info (self, classname):
+    def puppet_class_info(self, classname):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached puppet_class_info')
+        logging.debug('Reached puppet_class_info')
         if self.apiversion == 1:
-            logging.debug ('Passing to puppet_class_info_v1')
-            return self.puppet_class_info_v1 (classname)
+            logging.debug('Passing to puppet_class_info_v1')
+            return self.puppet_class_info_v1(classname)
         elif self.apiversion == 2:
-            logging.debug ('Passing to puppet_class_info_v2')
-            return self.puppet_class_info_v1 (classname)
+            logging.debug('Passing to puppet_class_info_v2')
+            return self.puppet_class_info_v1(classname)
 
-
-    def puppet_class_info_v1 (self, classname):
+    def puppet_class_info_v1(self, classname):
         """
         Returns puppet class info
         """
-        logging.debug ('Reached puppet_class_info_v1')
-        response = self.get("puppetclasses/" + classname, headers = self.headers)
+        logging.debug('Reached puppet_class_info_v1')
+        response = self.get(posixpath.join("puppetclasses", classname), headers=self.headers)
         return response.json()
 
-
-    def puppet_class_info_v2 (self, classname):
+    def puppet_class_info_v2(self, classname):
         """
         Returns puppet class info
         """
-        logging.debug ('Reached puppet_class_info_v2')
-        logging.debug ('Passing to puppet_class_info_v1')
-        return self.puppet_class_info_v1 (classname)
-
+        logging.debug('Reached puppet_class_info_v2')
+        logging.debug('Passing to puppet_class_info_v1')
+        return self.puppet_class_info_v1(classname)
 
-    def smart_class_info (self, scid):
+    def smart_class_info(self, scid):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached smart_class_info')
+        logging.debug('Reached smart_class_info')
+
         if self.apiversion == 1:
-            logging.debug ('Passing to smart_class_info_v1')
-            return self.smart_class_info_v1 (scid)
+            logging.debug('Passing to smart_class_info_v1')
+            return self.smart_class_info_v1(scid)
         if self.apiversion == 2:
-            logging.debug ('Passing to smart_class_info_v2')
-            return self.smart_class_info_v2 (scid)
-
+            logging.debug('Passing to smart_class_info_v2')
+            return self.smart_class_info_v2(scid)
 
-    def smart_class_info_v1 (self, scid):
+    def smart_class_info_v1(self, scid):
         """
         Returns smart class info
         """
-        logging.debug ('Reached smart_class_info_v1')
-        response = self.get("smart_class_parameters/" + str(scid), headers = self.headers)
+        logging.debug('Reached smart_class_info_v1')
+        response = self.get(posixpath.join("smart_class_parameters", str(scid)), headers=self.headers)
         return response.json()
 
-
-    def smart_class_info_v2 (self, scid):
+    def smart_class_info_v2(self, scid):
         """
         Returns smart class info
         """
-        logging.debug ('Reached smart_class_info_v2')
-        logging.debug ('Passing to smart_class_info_v1')
-        return self.smart_class_info_v1 (scid)
-
+        logging.debug('Reached smart_class_info_v2')
+        logging.debug('Passing to smart_class_info_v1')
+        return self.smart_class_info_v1(scid)
 
-    def override_smart_class (self, scid, params):
+    def override_smart_class(self, scid, params):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached mverride_smart_class')
+        logging.debug('Reached mverride_smart_class')
         if self.apiversion == 1:
-            logging.debug ('Passing to override_smart_class_v1')
-            self.override_smart_class_v1 (scid, params)
+            logging.debug('Passing to override_smart_class_v1')
+            self.override_smart_class_v1(scid, params)
         elif self.apiversion == 2:
-            logging.debug ('Passing to override_smart_class_v2')
-            self.override_smart_class_v1 (scid, params)
+            logging.debug('Passing to override_smart_class_v2')
+            self.override_smart_class_v1(scid, params)
 
-
-    def override_smart_class_v1 (self, scid, params):
+    def override_smart_class_v1(self, scid, params):
         """
         Overrides smart class parameters
         """
-        logging.debug ('Reached override_smart_class_v1')
-        request = self.post("smart_class_parameters/" + str(scid) + "/override_values", headers = self.headers, data = params)
-
+        logging.debug('Reached override_smart_class_v1')
+        request = self.post(posixpath.join("smart_class_parameters", str(scid),
+            "override_values"), headers=self.headers, data=params)
 
-    def override_smart_class_v2 (self, scid, params):
+    def override_smart_class_v2(self, scid, params):
         """
         Overrides smart class parameters
         """
-        logging.debug ('Reached override_smart_class_v2')
-        logging.debug ('Passing to override_smart_class_v1')
-        self.override_smart_class_v1 (scid, params)
-
+        logging.debug('Reached override_smart_class_v2')
+        logging.debug('Passing to override_smart_class_v1')
+        self.override_smart_class_v1(scid, params)
 
-    def get_hostgroup_puppetclasses (self, hostgroup_id):
+    def get_hostgroup_puppetclasses(self, hostgroup_id):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_hostgroup_puppetclasses')
+        logging.debug('Reached get_hostgroup_puppetclasses')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_hostgroup_puppetclasses_v1')
-            return self.get_hostgroup_puppetclasses_v1 (hostgroup_id)
+            logging.debug('Passing to get_hostgroup_puppetclasses_v1')
+            return self.get_hostgroup_puppetclasses_v1(hostgroup_id)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_hostgroup_puppetclasses_v2')
-            return self.get_hostgroup_puppetclasses_v2 (hostgroup_id)
+            logging.debug('Passing to get_hostgroup_puppetclasses_v2')
+            return self.get_hostgroup_puppetclasses_v2(hostgroup_id)
 
-
-    def get_hostgroup_puppetclasses_v1 (self, hostgroup_id):
+    def get_hostgroup_puppetclasses_v1(self, hostgroup_id):
         """
         Returns info about all hostgroup's puppetclasses
         """
-        logging.debug ('Reached get_hostgroup_puppetclasses_v1')
-        response = self.get("hostgroups/" + str(hostgroup_id) + "/puppetclasses", headers = self.headers)
+        logging.debug('Reached get_hostgroup_puppetclasses_v1')
+        response = self.get(posixpath.join("hostgroups", str(hostgroup_id), "puppetclasses"), headers=self.headers)
         return response.json()
 
-
-    def get_hostgroup_puppetclasses_v2 (self, hostgroup_id):
+    def get_hostgroup_puppetclasses_v2(self, hostgroup_id):
         """
         Returns info about all hostgroup's puppetclasses
         """
-        logging.debug ('Reached get_hostgroup_puppetclasses_v2')
-        params = {'hostgroup_id': str (hostgroup_id) }
-        response = self.get ('puppetclasses/', params=params)
-        return response.json ()
-
+        logging.debug('Reached get_hostgroup_puppetclasses_v2')
+        params = {'hostgroup_id': str(hostgroup_id)}
+        response = self.get('puppetclasses', params=params)
+        return response.json()
 
-    def add_puppet_class_to_host (self, hostname, params):
+    def add_puppet_class_to_host(self, hostname, params):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached add_puppet_class_to_host')
+        logging.debug('Reached add_puppet_class_to_host')
         if self.apiversion == 1:
-            logging.debug ('Passing to add_puppet_class_to_host_v1')
-            self.add_puppet_class_to_host_v1 (hostname, params)
+            logging.debug('Passing to add_puppet_class_to_host_v1')
+            self.add_puppet_class_to_host_v1(hostname, params)
         if self.apiversion == 2:
-            logging.debug ('Passing to add_puppet_class_to_host_v2')
-            self.add_puppet_class_to_host_v2 (hostname, params)
+            logging.debug('Passing to add_puppet_class_to_host_v2')
+            self.add_puppet_class_to_host_v2(hostname, params)
 
-
-    def add_puppet_class_to_host_v1 (self, hostname, params):
+    def add_puppet_class_to_host_v1(self, hostname, params):
         """
         Adds the required puppet class to the host
         """
-        logging.debug ('Reached add_puppet_class_to_host_v1')
-        request = self.post("hosts/" + hostname + "/puppetclass_ids", headers = self.headers, data = params)
-
+        logging.debug('Reached add_puppet_class_to_host_v1')
+        request = self.post(posixpath.join("hosts", hostname, "puppetclass_ids"), headers=self.headers, data=params)
 
-    def add_puppet_class_to_host_v2 (self, hostname, params):
+    def add_puppet_class_to_host_v2(self, hostname, params):
         """
         Adds the required puppet class to the host
         """
-        logging.debug ('Reached add_puppet_class_to_host_v2')
-        logging.debug ('Passing to add_puppet_class_to_host_v1')
-        self.add_puppet_class_to_host_v1 (hostname, params)
+        logging.debug('Reached add_puppet_class_to_host_v2')
+        logging.debug('Passing to add_puppet_class_to_host_v1')
+        self.add_puppet_class_to_host_v1(hostname, params)
 
-
-    def get_subnets (self):
+    def get_subnets(self):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_subnets')
+        logging.debug('Reached get_subnets')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_subnets_v1')
-            return self.get_subnets_v1 ()
+            logging.debug('Passing to get_subnets_v1')
+            return self.get_subnets_v1()
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_subnets_v2')
-            return self.get_subnets_v2 ()
-
+            logging.debug('Passing to get_subnets_v2')
+            return self.get_subnets_v2()
 
-    def get_subnets_v1 (self):
+    def get_subnets_v1(self):
         """
         Returns all available subnets
         """
-        logging.debug ('Reached get_subnets_v1')
-        subnets_count = self.get("subnets", headers = self.headers).json()["total"]
-        response = self.get("subnets?per_page={}".format(subnets_count), headers = self.headers)
+        logging.debug('Reached get_subnets_v1')
+        subnets_count = self.get("subnets", headers=self.headers).json()["total"]
+        response = self.get("subnets?per_page={}".format(subnets_count), headers=self.headers)
         return response.json()
 
-
-    def get_subnets_v2 (self):
+    def get_subnets_v2(self):
         """
         Return all available subnets
         """
-        logging.debug ('Reached get_subnets_v2')
-        logging.debug ('Passing to get_subnets_v1')
-        return self.get_subnets_v1 ()
-
+        logging.debug('Reached get_subnets_v2')
+        logging.debug('Passing to get_subnets_v1')
+        return self.get_subnets_v1()
 
-    def get_host_reports (self, hostname, last=False):
+    def get_host_reports(self, hostname, last=False):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_host_reports')
+        logging.debug('Reached get_host_reports')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_host_reports_v1')
-            return self.get_host_reports_v1 (hostname, last)
+            logging.debug('Passing to get_host_reports_v1')
+            return self.get_host_reports_v1(hostname, last)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_host_reports_v2')
-            return self.get_host_reports_v2 (hostname, last)
+            logging.debug('Passing to get_host_reports_v2')
+            return self.get_host_reports_v2(hostname, last)
 
-
-    def get_host_reports_v1 (self, hostname, last):
+    def get_host_reports_v1(self, hostname, last):
         """
         Returns all reports (or only the last one) for the host
         """
-        if not last:
-            response = self.get("hosts/" + hostname + "/config_reports", headers = self.headers)
-        else:
-            response = self.get("hosts/" + hostname + "/config_reports/last", headers = self.headers)
-        return response.json()
+        _rq = posixpath.join("hosts", hostname, "config_reports")
+
+        if last:
+            _rq = posixpath.join(_rq, "last")
 
+        response = self.get(_rq, headers=self.headers)
 
-    def get_host_reports_v2 (self, hostname, last):
+        return response.json()
+
+    def get_host_reports_v2(self, hostname, last):
         """
         Returns all reports (or only the last one) for the host
         """
-        logging.debug ('Reached get_host_reports_v2')
-        logging.debug ('hostname = [%s]' % hostname)
-        logging.debug ('last = [%s]' % last)
+        logging.debug('Reached get_host_reports_v2')
+        logging.debug('hostname = [%s]' % hostname)
+        logging.debug('last = [%s]' % last)
         if not last:
             params = {'search': 'host=%s' % hostname}
-            response = self.get ('config_reports', params=params).json ()
-            logging.debug ('Received response:')
-            logging.debug (response)
+            response = self.get('config_reports', params=params).json()
+            logging.debug('Received response:')
+            logging.debug(response)
         else:
-            host_id = self.get_host_info (hostname).get ('id')
-            logging.debug ('host_id = [%s]' % host_id)
-            response = self.get ('hosts/%s/config_reports/last' % host_id).json ()
-            logging.debug ('Received response:')
-            logging.debug (response)
+            host_id = self.get_host_info(hostname).get('id')
+            logging.debug('host_id = [%s]' % host_id)
+            response = self.get(posixpath.join('hosts', str(host_id), "config_reports", "last")).json()
+            logging.debug('Received response:')
+            logging.debug(response)
         return response
 
-
-    def host_power (self, hostname, action):
+    def host_power(self, hostname, action):
         """
         wrapper for api v1/v2
         NB currently (2023-02-08) host power is managed via vsphere api
         """
-        logging.debug ('Reached host_power')
+        logging.debug('Reached host_power')
         if self.apiversion == 1:
-            logging.debug ('Passing to host_power_v1')
-            self.host_power_v1 (hostname, action)
+            logging.debug('Passing to host_power_v1')
+            self.host_power_v1(hostname, action)
         elif self.apiversion == 2:
-            logging.debug ('Passing to host_power_v2')
-            self.host_power_v2 (hostname, action)
-
+            logging.debug('Passing to host_power_v2')
+            self.host_power_v2(hostname, action)
 
-    def host_power_v1 (self, hostname, action):
+    def host_power_v1(self, hostname, action):
         """
         Turns on/off power on the host
         """
-        logging.debug ('Reached host_power_v1')
+        logging.debug('Reached host_power_v1')
         actions = ["start", "stop"]
+
         if action not in actions:
             raise ForemanAPIError("500 - Incorrect power action was provided")
-        params = json.dumps({"power_action": action})
-        request = self.put("hosts/" + hostname + "/power", headers = self.headers, data = params)
 
+        params = json.dumps({"power_action": action})
+        request = self.put(posixpath.join("hosts", hostname, "power"), headers=self.headers, data=params)
 
-    def host_power_v2 (self, hostname, action):
+    def host_power_v2(self, hostname, action):
         """
         Turns on/off power on the host
         """
-        logging.debug ('Reached host_power_v2')
-        logging.debug ('Passing to host_power_v1')
-        logging.debug ('host = [%s]' % host)
-        logging.debug ('action = [%s]' % host)
-        self.host_power_v1 (hostname, action) 
+        logging.debug('Reached host_power_v2')
+        logging.debug('Passing to host_power_v1')
+        logging.debug('host = [%s]' % hostname)
+        logging.debug('action = [%s]' % action)
+        self.host_power_v1(hostname, action)
 
-
-    def get_report (self, id):
+    def get_report(self, id):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_report')
+        logging.debug('Reached get_report')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_report_v1')
-            return self.get_report_v1 (id)
-        elif self.apiversion ==  2:
-            logging.debug ('Passing to get_report_v2')
-            return self.get_report_v2 (id)
-
+            logging.debug('Passing to get_report_v1')
+            return self.get_report_v1(id)
+        elif self.apiversion == 2:
+            logging.debug('Passing to get_report_v2')
+            return self.get_report_v2(id)
 
-    def get_report_v1 (self, id):
+    def get_report_v1(self, id):
         """
         Returns a foreman report with specified id
         :param id: int, id of the required report
         :return: response in json format
         """
-        response = self.get("config_reports/" + str(id), headers = self.headers)
+        response = self.get(posixpath.join("config_reports", str(id)), headers=self.headers)
         return response.json()
 
-
-    def get_report_v2 (self, id):
+    def get_report_v2(self, id):
         """
         Returns a foreman report with specified id
         :param id: int, id of the required report
         :return: response in json format
         """
-        logging.debug ('Reached get_report_v2')
-        logging.debug ('Passing to get_report_v1')
-        return self.get_report_v1 (id)
+        logging.debug('Reached get_report_v2')
+        logging.debug('Passing to get_report_v1')
+        return self.get_report_v1(id)
 
-    
-    def get_hostgroup_id (self, hostgroup_name):
+    def get_hostgroup_id(self, hostgroup_name):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_hostgroup_id')
+        logging.debug('Reached get_hostgroup_id')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_hostgroup_id_v1')
-            return self.get_hostgroup_id_v1 (hostgroup_name)
+            logging.debug('Passing to get_hostgroup_id_v1')
+            return self.get_hostgroup_id_v1(hostgroup_name)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_hostgroup_id_v2')
-            return self.get_hostgroup_id_v2 (hostgroup_name)
+            logging.debug('Passing to get_hostgroup_id_v2')
+            return self.get_hostgroup_id_v2(hostgroup_name)
 
-
-    def get_hostgroup_id_v1 (self, hostgroup_name):
+    def get_hostgroup_id_v1(self, hostgroup_name):
         """
         Returns id of the required hostgroup
         :param hostgroup_name: str
         :return: int
         """
-        logging.debug ('Reached get_hostgroup_id_v1')
-        hostgroups = self.get("hostgroups", headers = self.headers).json()["results"]
+        logging.debug('Reached get_hostgroup_id_v1')
+        hostgroups = self.get("hostgroups", headers=self.headers).json()["results"]
+
         for hostgroup in hostgroups:
-            if hostgroup["name"] == hostgroup_name:
+            if hostgroup.get("name") == hostgroup_name:
                 return hostgroup.get ('id')
+        
+        logging.debug("Hostgroup [%s] not found, returning None" % hostgroup_name)
+        return None
 
-
-    def get_hostgroup_id_v2 (self, hostgroup_name):
+    def get_hostgroup_id_v2(self, hostgroup_name):
         """
         Returns id of the required hostgroup
         :param hostgroup_name: str
         :return: int
         """
-        logging.debug ('Reached get_hostgroup_id_v2')
-        logging.debug ('Passing to get_hostgroup_id_v1')
-        return self.get_hostgroup_id_v1 (hostgroup_name)
+        logging.debug('Reached get_hostgroup_id_v2')
+        logging.debug('Passing to get_hostgroup_id_v1')
+        return self.get_hostgroup_id_v1(hostgroup_name)
 
-
-    def get_organization_id (self, organization_name):
+    def get_organization_id(self, organization_name):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached get_organization_id')
+        logging.debug('Reached get_organization_id')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_organization_id_v1')
-            return self.get_organization_id_v1 (organization_name)
+            logging.debug('Passing to get_organization_id_v1')
+            return self.get_organization_id_v1(organization_name)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_organization_id_v2')
-            return self.get_organization_id_v2 (organization_name)
-
+            logging.debug('Passing to get_organization_id_v2')
+            return self.get_organization_id_v2(organization_name)
 
-    def get_organization_id_v1 (self, organization_name):
+    def get_organization_id_v1(self, organization_name):
         """
         Returns id of the required organization
         :param organization_name: str
         :return: int
         """
-        logging.debug ('Reached get_organization_id_v1')
+        logging.debug('Reached get_organization_id_v1')
         organization_id = None
-        organizations_count = self.get("organizations", headers = self.headers).json()["total"]
-        organizations = self.get("organizations?per_page={}".format(organizations_count), headers = self.headers).json()["results"]
-        
+        organizations_count = self.get("organizations", headers=self.headers).json()["total"]
+        organizations = self.get("organizations?per_page={}".format(
+            organizations_count), headers=self.headers).json()["results"]
+
         try:
-            organization_id = next(organization["id"] for organization in organizations if organization["name"] == organization_name)
+            organization_id = next(organization["id"]
+                                   for organization in organizations if organization["name"] == organization_name)
             return organization_id
         except StopIteration:
             return None
 
-
-    def get_organization_id_v2 (self, organization_name):
+    def get_organization_id_v2(self, organization_name):
         """
         Returns id of the required organization
         :param organization_name: str
         :return: int
         """
-        logging.debug ('Reached get_organization_id_v2')
-        logging.debug ('Passing to get_organization_id_v1')
-        return self.get_organization_id_v1 (organization_name)
-
+        logging.debug('Reached get_organization_id_v2')
+        logging.debug('Passing to get_organization_id_v1')
+        return self.get_organization_id_v1(organization_name)
 
-    def get_os_id (self, os_name):
+    def get_os_id(self, os_name):
         """
         Wrapper for api v1/v2
         """
-        logging.debug ('Reached get_os_id')
-        logging.debug ('os_name = [%s]')
+        logging.debug('Reached get_os_id')
+        logging.debug('os_name = [%s]')
         if self.apiversion == 1:
-            logging.error ('Not supported in v1, returning None')
+            logging.error('Not supported in v1, returning None')
             return None
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_os_id_v2')
-            return self.get_os_id_v2 (os_name)
+            logging.debug('Passing to get_os_id_v2')
+            return self.get_os_id_v2(os_name)
 
-
-    def get_os_id_v2 (self, os_name):
+    def get_os_id_v2(self, os_name):
         """
         returns operating system id
         """
-        logging.debug ('Reached get_os_id_v2')
-        logging.debug ('os_name = [%s]' % os_name)
+        logging.debug('Reached get_os_id_v2')
+        logging.debug('os_name = [%s]' % os_name)
         params = {'search': 'name=%s' % os_name}
-        response = self.get ('operatingsystems', params=params).json ()
-        logging.debug ('response is:')
-        logging.debug (response)
-        results = response.get ('results')
+        response = self.get('operatingsystems', params=params).json()
+        logging.debug('response is:')
+        logging.debug(response)
+        results = response.get('results')
         for result in results:
-            if result.get ('description') == os_name:
-                os_id = result.get ('id')
-                logging.debug ('Found os, id = [%s]' % os_id)
-                return os_id
-        logging.error ('OS not found, returning None')
-        return None
+            if result.get('description') != os_name:
+                continue
 
+            os_id = result.get('id')
+            logging.debug('Found os, id = [%s]' % os_id)
+            return os_id
+
+        logging.error('OS not found, returning None')
+        return None
 
-    def set_host_expiry (self, hostname, expiry):
+    def set_host_expiry(self, hostname, expiry):
         """
         wrapper for api v1/v2
         """
-        logging.debug ('Reached set_host_expiry')
+        logging.debug('Reached set_host_expiry')
         if self.apiversion == 1:
-            logging.debug ('Passing to set_host_expiry_v1')
-            self.set_host_expiry_v1 (hostname, expiry)
+            logging.debug('Passing to set_host_expiry_v1')
+            self.set_host_expiry_v1(hostname, expiry)
         elif self.apiversion == 2:
-            logging.debug ('Passing to set_host_expiry_v2')
-            self.set_host_expiry_v2 (hostname, expiry)
+            logging.debug('Passing to set_host_expiry_v2')
+            self.set_host_expiry_v2(hostname, expiry)
 
-
-    def set_host_expiry_v1 (self, hostname, expiry):
+    def set_host_expiry_v1(self, hostname, expiry):
         """
         Attempts to set host expiry date
         :param hostname: full hostname 
         :param expiry: expiry date in format yyyy-mm-dd
         """
-        logging.debug ('Reached set_host_expiry_v1')
-        pl={}
-        pl['host']={}
-        pl['host']['expired_on']=expiry
-        try:
-            self.update_host(hostname,pl)
-        except ForemanAPIError as err:
-            raise(err)
-    
+        logging.debug('Reached set_host_expiry_v1')
+        pl = {}
+        pl['host'] = {}
+        pl['host']['expired_on'] = expiry
+        self.update_host(hostname, pl)
 
-    def set_host_expiry_v2 (self, hostname, expiry):
+    def set_host_expiry_v2(self, hostname, expiry):
         """
         Attempts to set host expiry date
         :param hostname: full hostname 
         :param expiry: expiry date in format yyyy-mm-dd
         """
-        logging.debug ('Reached set_host_expiry_v2')
-        logging.debug ('Passing to set_host_expiry_v1')
-        self.set_host_expiry_v1 (hostname, expiry)
+        logging.debug('Reached set_host_expiry_v2')
+        logging.debug('Passing to set_host_expiry_v1')
+        self.set_host_expiry_v1(hostname, expiry)
 
-
-    def get_image_uuid (self, os_name, image_name):
+    def get_image_uuid(self, os_name, image_name):
         """
         wrapper api v1/v2
         """
-        logging.debug ('Reached get_image_uuid')
+        logging.debug('Reached get_image_uuid')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_image_uuid_v1')
-            return self.get_image_uuid_v1 (os_name, image_name)
+            logging.debug('Passing to get_image_uuid_v1')
+            return self.get_image_uuid_v1(os_name, image_name)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_image_uuid_v2')
-            return self.get_image_uuid_v2 (os_name, image_name)
-
+            logging.debug('Passing to get_image_uuid_v2')
+            return self.get_image_uuid_v2(os_name, image_name)
 
-    def get_image_uuid_v1 (self, os_name, image_name):
+    def get_image_uuid_v1(self, os_name, image_name):
         """
         Returns OS image uuid
         :param os_name: str
         :param image_name: str
         :return: str
         """
-        logging.debug ('Reached get_image_uuid_v1')
+        logging.debug('Reached get_image_uuid_v1')
         os_list = self.get("operatingsystems", headers=self.headers).json()["results"]
         try:
             os_id = next(os["id"] for os in os_list if os["description"] == os_name)
-            images_list = self.get("operatingsystems/{}/images".format(os_id)).json()["results"]
+            images_list = self.get(posixpath.join("operatingsystems", str(os_id), "images")).json()["results"]
             image_uuid = next(image["uuid"] for image in images_list if image["name"] == image_name)
             return image_uuid
         except StopIteration:
             return None
 
-    
-    def get_image_uuid_v2 (self, os_name, image_name):
+    def get_image_uuid_v2(self, os_name, image_name):
         """
         Returns OS image uuid
         :param os_name: str
         :param image_name: str
         :return: str
         """
-        logging.debug ('Reached get_image_uuid_v2')
-        logging.debug ('Passing to get_image_uuid_v1')
-        return self.get_image_uuid_v1 (os_name, image_name)
+        logging.debug('Reached get_image_uuid_v2')
+        logging.debug('Passing to get_image_uuid_v1')
+        return self.get_image_uuid_v1(os_name, image_name)
 
-
-    def get_flavor_id (self, compute_resource_id, flavor_name):
+    def get_flavor_id(self, compute_resource_id, flavor_name):
         """
         wrapper api v1/v2
         """
-        logging.debug ('Reached get_flavor_id')
+        logging.debug('Reached get_flavor_id')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_flavor_id_v1')
-            return self.get_flavor_id_v1 (compute_resource_id, flavor_name)
+            logging.debug('Passing to get_flavor_id_v1')
+            return self.get_flavor_id_v1(compute_resource_id, flavor_name)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_flavor_id_v2')
-            return self.get_flavor_id_v2 (compute_resource_id, flavor_name)
-
+            logging.debug('Passing to get_flavor_id_v2')
+            return self.get_flavor_id_v2(compute_resource_id, flavor_name)
 
-    def get_flavor_id_v1 (self, compute_resource_id, flavor_name):
+    def get_flavor_id_v1(self, compute_resource_id, flavor_name):
         """
         :param compute_resource_id: int
         :param flavor_name: str
         :return: int
         """
-        logging.debug ('Reached get_flavor_id_v1')
-        flavors_list = self.get("compute_resources/{}/available_flavors".format(compute_resource_id)).json()["results"]
+        logging.debug('Reached get_flavor_id_v1')
+        flavors_list = self.get(posixpath.join("compute_resources", str(compute_resource_id),
+            "available_flavors")).json()["results"]
+
         try:
             flavor_id = next(flavor["id"] for flavor in flavors_list if flavor["name"] == flavor_name)
             return flavor_id
         except StopIteration:
             return None
-    
 
-    def get_flavor_id_v2 (self, compute_resource_id, flavor_name):
+    def get_flavor_id_v2(self, compute_resource_id, flavor_name):
         """
         :param compute_resource_id: int
         :param flavor_name: str
         :return: int
         """
-        logging.debug ('Reached get_flavor_id_v2')
-        logging.debug ('Passing to get_flavor_id_v1')
-        return self.get_flavor_id_v1 (compute_resource_id, flavor_name)
-
+        logging.debug('Reached get_flavor_id_v2')
+        logging.debug('Passing to get_flavor_id_v1')
+        return self.get_flavor_id_v1(compute_resource_id, flavor_name)
 
-    def get_tenant_id (self, compute_resource_id):
+    def get_tenant_id(self, compute_resource_id):
         """
         wrapper api v1/v2
         """
-        logging.debug ('Reached get_tenant_id')
+        logging.debug('Reached get_tenant_id')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_tenant_id_v1')
-            return self.get_tenant_id_v1 (compute_resource_id)
+            logging.debug('Passing to get_tenant_id_v1')
+            return self.get_tenant_id_v1(compute_resource_id)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_tenant_id_v2')
-            return self.get_tenant_id_v2 (compute_resource_id)
-
+            logging.debug('Passing to get_tenant_id_v2')
+            return self.get_tenant_id_v2(compute_resource_id)
 
-    def get_tenant_id_v1 (self, compute_resource_id):
+    def get_tenant_id_v1(self, compute_resource_id):
         """
         :param compute_resource_id: int
         :return: str
         """
-        logging.debug ('Reached get_tenant_id_v1')
-        compute_resource_info = self.get("compute_resources/{}".format(compute_resource_id)).json()
+        logging.debug('Reached get_tenant_id_v1')
+        compute_resource_info = self.get(posixpath.join("compute_resources", str(compute_resource_id))).json()
+
         try:
             tenant_id = compute_resource_info["compute_attributes"][0]["attributes"]["tenant_id"]
             return tenant_id
         except KeyError:
             return None
-    
 
-    def get_tenant_id_v2 (self, compute_resource_id):
+    def get_tenant_id_v2(self, compute_resource_id):
         """
         :param compute_resource_id: int
         :return: str
         """
-        logging.debug ('Reached get_tenant_id_v2')
-        logging.debug ('Passing to get_tenant_id_v1')
-        return self.get_tenant_id_v1 (compute_resource_id)
-
+        logging.debug('Reached get_tenant_id_v2')
+        logging.debug('Passing to get_tenant_id_v1')
+        return self.get_tenant_id_v1(compute_resource_id)
 
-    def get_hosts_uuids (self, hostnames):
+    def get_hosts_uuids(self, hostnames):
         """
         wrapper api v1/v2
         """
-        logging.debug ('Reached get_hosts_uuids')
+        logging.debug('Reached get_hosts_uuids')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_hosts_uuids_v1')
-            return self.get_hosts_uuids_v1 (hostnames)
+            logging.debug('Passing to get_hosts_uuids_v1')
+            return self.get_hosts_uuids_v1(hostnames)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_hosts_uuids_v2')
-            return self.get_hosts_uuids_v2 (hostnames)
+            logging.debug('Passing to get_hosts_uuids_v2')
+            return self.get_hosts_uuids_v2(hostnames)
 
-
-    def get_hosts_uuids_v1 (self, hostnames):
+    def get_hosts_uuids_v1(self, hostnames):
         """
         :param hostnames: list
         :return: dict
         """
-        logging.debug ('Reached get_hosts_uuids_v1')
+        logging.debug('Reached get_hosts_uuids_v1')
         hosts_total_qty = self.get("hosts", params={"per_page": 1}).json()["total"]
-        hostnames_uuids = {host["name"]: host["uuid"] for host in self.get("hosts", params={"per_page": hosts_total_qty}).json()["results"]}
+        hostnames_uuids = {host["name"]: host["uuid"]
+                           for host in self.get("hosts", params={"per_page": hosts_total_qty}).json()["results"]}
         uuids = {hostname: uuid for hostname, uuid in hostnames_uuids.items() if hostname in hostnames}
         return uuids
-    
 
-    def get_hosts_uuids_v2 (self, hostnames):
+    def get_hosts_uuids_v2(self, hostnames):
         """
         :param hostnames: list
         :return: dict
         """
-        logging.debug ('Reached get_hosts_uuids_v2')
-        logging.debug ('Passing to get_hosts_uuids_v1')
-        return self.get_hosts_uuids_v1 (hostnames)
-
+        logging.debug('Reached get_hosts_uuids_v2')
+        logging.debug('Passing to get_hosts_uuids_v1')
+        return self.get_hosts_uuids_v1(hostnames)
 
-    def get_host_uuid (self, hostname):
+    def get_host_uuid(self, hostname):
         """
         wrapper api v1/v2
         """
-        logging.debug ('Reached get_host_uuid')
+        logging.debug('Reached get_host_uuid')
         if self.apiversion == 1:
-            logging.debug ('Passing to get_host_uuid_v1')
-            return self.get_host_uuid_v1 (hostname)
+            logging.debug('Passing to get_host_uuid_v1')
+            return self.get_host_uuid_v1(hostname)
         elif self.apiversion == 2:
-            logging.debug ('Passing to get_host_uuid_v2')
-            return self.get_host_uuid_v2 (hostname)
+            logging.debug('Passing to get_host_uuid_v2')
+            return self.get_host_uuid_v2(hostname)
 
-
-    def get_host_uuid_v1 (self, hostname):
+    def get_host_uuid_v1(self, hostname):
         """
         :param hostname: str
         :return: str
         """
-        logging.debug ('Reached get_host_uuid_v1')
+        logging.debug('Reached get_host_uuid_v1')
         try:
-            return self.get("hosts/{}".format(hostname)).json()["uuid"]
+            return self.get(posixpath.join("hosts", hostname)).json()["uuid"]
         except KeyError:
             return None
 
-    def get_host_uuid_v2 (self, hostname):
+    def get_host_uuid_v2(self, hostname):
         """
         :param hostname: str
         :return: str
         """
-        logging.debug ('Reached get_host_uuid_v2')
-        logging.debug ('Passing to get_host_uuid_v1')
-        return self.get_host_uuid_v1 (hostname)
-    
+        logging.debug('Reached get_host_uuid_v2')
+        logging.debug('Passing to get_host_uuid_v1')
+        return self.get_host_uuid_v1(hostname)
+
     def get_all_users(self):
         """
         :return: list
         """
         users_qty = self.get("users", params={"per_page": 1}).json()["total"]
-        users = [{"firstname": user["firstname"], "lastname": user["lastname"], "login": user["login"]} for user in self.get("users", params={"per_page": users_qty}).json()["results"]]
+        users = [{"firstname": user["firstname"], "lastname": user["lastname"], "login": user["login"]}
+                 for user in self.get("users", params={"per_page": users_qty}).json()["results"]]
         return users
-    
+
     def get_all_usergroups(self):
         """
         :return: list
         """
         groups_qty = self.get("usergroups", params={"per_page": 1}).json()["total"]
         groups = [group["name"] for group in self.get("usergroups", params={"per_page": groups_qty}).json()["results"]]
         return groups
```

## oc_cdtapi/JenkinsAPI.py

```diff
@@ -1,15 +1,16 @@
 # requires python-requests rpm package
+from enum import Enum
 import requests
 from .API import HttpAPI, HttpAPIError
 from string import Template
 import json
 from collections import namedtuple, OrderedDict
 import re
-import xml.etree.ElementTree as ET;
+import xml.etree.ElementTree as ET
 import posixpath
 import sys
 
 
 class JenkinsError(HttpAPIError):
     def __str__(self):
         return 'Error communicating with Jenkins: ' + self.text + ': Code ' + str(self.code) + ' ' + self.url
@@ -38,420 +39,430 @@
 
     """
 
     _error = JenkinsError
     _env_prefix = 'JENKINS'
 
     def re(self, req):
-        if req and req[0] == '!':
-            req = req[1:]
-            return posixpath.join( self.root, req );
-        return posixpath.join( self.root, req, 'api', 'json' );
+        if req and req.startswith('!'):
+            req = req.lstrip('!')
+            return posixpath.join(self.root, req)
+
+        return posixpath.join(self.root, req, 'api', 'json')
 
     def post(self, req, *vargs, **kvargs):
         # We need all post requests to be processed in a different way in re(),
         # but do not wan't to rewrite post(). So we pass a little flag to be checked in re()
         return super(Jenkins, self).post('!' + req, *vargs, **kvargs)
 
     def list_jobs(self, prefix=None, suffix=None):
         """Gets job list"""
         jobs = self.get('', params={'tree': 'jobs[name]'})
         return filter(lambda x: (not prefix or x.startswith(prefix)) and (not suffix or x.endswith(suffix)),
                       map(lambda x: x['name'], jobs.json().get('jobs', [])))
+
     def get_node(self, node):
         """Gets config.xml for specific slave"""
-        config = self.get( posixpath.join( 'computer', node, 'config.xml') );
+        config = self.get(posixpath.join('computer', node, 'config.xml'))
         return config.text
 
     def put_node(self, node, config):
         """Saves config.xml for a node (or creates new node)"""
-        request = posixpath.join( 'computer', node, 'config.xml' );
+        request = posixpath.join('computer', node, 'config.xml')
         params = None
-        headers = {'content-type' : 'application/xml'}
+        headers = {'content-type': 'application/xml'}
 
         try:
             self.get_node(node)
         except JenkinsError as e:
-            if e.code == 404: request = posixpath.join( 'computer', 'doCreateItem' );
+            if e.code == 404:
+                request = posixpath.join('computer', 'doCreateItem')
             params = {'name': node}
 
-        if self.readonly: return None
+        if self.readonly:
+            return None
+
         put = self.post(request, data=config, params=params, headers=headers)
         return put
 
-    def delete_node( self, node ):
+    def delete_node(self, node):
         """Deletes node from CI"""
-        if self.readonly: return None
-        return self.post( posixpath.join( 'computer', node, 'doDelete' ) );
+        if self.readonly:
+            return None
+        return self.post(posixpath.join('computer', node, 'doDelete'))
 
-    def get_node_label_from_config( self, config ):
+    def get_node_label_from_config(self, config):
         """
         Get the exact XML tag value with XPATH: label
         :param self: self reference
         :param config: xml string with a configuration of node
         :return: <label> tag text
         """
-        obj_xml = ET.fromstring( config );
-        xml_tag = obj_xml.find( 'label' );
+        obj_xml = ET.fromstring(config)
+        xml_tag = obj_xml.find('label')
 
-        if ( xml_tag is None ) or ( xml_tag.text is None ) or ( len( xml_tag.text.strip() ) == 0 ):
-            return "";
+        if (xml_tag is None) or (xml_tag.text is None) or (len(xml_tag.text.strip()) == 0):
+            return ""
 
-        return xml_tag.text;
+        return xml_tag.text
 
     def get_node_label(self, node, config=None):
-        if not config: config = self.get_node(node)
-        return self.get_node_label_from_config( config ).split(' ')
+        if not config:
+            config = self.get_node(node)
+        return self.get_node_label_from_config(config).split(' ')
 
-    def set_node_label_in_config( self, config, label ):
+    def set_node_label_in_config(self, config, label):
         """
         set <label> tag in XML config
         :param self: self reference
         :param config: string with XML node configuration
         :return: string with edited 'config' with <lable> tag content set to 'label'
         """
-        obj_xml = ET.fromstring( config );
-        xml_tag = obj_xml.find( 'label' );
+        obj_xml = ET.fromstring(config)
+        xml_tag = obj_xml.find('label')
 
-        if ( xml_tag is None ):
-            xml_tag = ET.SubElement( obj_xml, 'label' );
+        if (xml_tag is None):
+            xml_tag = ET.SubElement(obj_xml, 'label')
 
-        xml_tag.text = label;
+        xml_tag.text = label
 
-        return ET.tostring( obj_xml, encoding='utf8' );
+        return ET.tostring(obj_xml, encoding='utf8')
 
     def set_node_label(self, node, label):
         config = self.get_node(node)
-        config = self.set_node_label_in_config( config, ' '.join(label))
+        config = self.set_node_label_in_config(config, ' '.join(label))
         return self.put_node(node, config)
 
     def enable_node(self, job):
-        if self.readonly: return None
-        return self.post( posixpath.join( 'computer', job, 'enable') );
+        if self.readonly:
+            return None
+        return self.post(posixpath.join('computer', job, 'enable'))
 
     def disable_node(self, job):
-        if self.readonly: return None
-        return self.post( posixpath.join( 'computer', job, 'disable') )
+        if self.readonly:
+            return None
+        return self.post(posixpath.join('computer', job, 'disable'))
 
     def is_node_idle(self, node):
         """Retrieve 'idle' attribute of a node via newer JSON API (may require Jenkins 2.x)."""
-        return json.loads(
-            self.get("computer/{}/api/json".format(node)).content
-        )['idle']
+        return self.get(posixpath.join("computer", node, "api", "json")).json().get('idle')
 
-    def list_nodes( self ):
+    def list_nodes(self):
         """
         List all active nodes (except master one)
         :return: List of strings with node names, possible empty
         """
-        raw_data = self.get( "computer", params = { "tree" : "computer[displayName]" } )
+        raw_data = self.get("computer", params={"tree": "computer[displayName]"})
         str_data = raw_data.text
 
 #        return map( lambda x: x[ "displayName" ], json.loads( self.get( "computer", params = { "tree" : "computer[displayName]" } ).text )[ "computer" ] );
-        return [x[ "displayName" ] for x in json.loads( str_data )[ "computer" ]];
-
+        return [x["displayName"] for x in json.loads(str_data)["computer"]]
 
-    def job_xml_enable( self, config ):
+    def job_xml_enable(self, config):
         """
         Enables jenkins job by modifying XML tag (XPATH=) in the configuration
         :param self: self reference
         :param config: xml string from a config
         :return: xml string with <disabled> tag value modified to 'true'
         """
-        obj_xml = ET.fromstring( config );
-        xml_tag = obj_xml.find( 'disabled' );
+        obj_xml = ET.fromstring(config)
+        xml_tag = obj_xml.find('disabled')
 
         if xml_tag is None:
-            return config;
+            return config
 
-        xml_tag.text = "false";
+        xml_tag.text = "false"
 
-        return ET.tostring( obj_xml, encoding='utf8' );
+        return ET.tostring(obj_xml, encoding='utf8')
 
     def copy_job(self, config, j_name, parameters={}, enabled=True, use_template=False):
         """Create or update job by template"""
 
-        if config[0] != '<':    config = self.get_job(config)
+        if config[0] != '<':
+            config = self.get_job(config)
         parameters['name'] = j_name
         if enabled:
-            config = self.job_xml_enable( config );
+            config = self.job_xml_enable(config)
 
-        cfg_type = str (type (config) )
+        cfg_type = str(type(config))
         if cfg_type.find('byte') != -1:
-            config = str (config, 'UTF-8')
+            config = str(config, 'UTF-8')
 
         if use_template:
             config = Template(config).safe_substitute(parameters)
         else:
             config = config.format(**parameters)
 
         put = self.put_job(j_name, config)
         #		if enabled: self.enable_job(j_name)
         return put
 
     def get_job(self, job):
         """Gets config.xml for a job"""
-        config = self.get( posixpath.join( 'job', job, 'config.xml') );
+        config = self.get(posixpath.join('job', job, 'config.xml'))
         return config.text
 
     def put_job(self, job, config):
         """Saves config.xml for a job (or creates new job)"""
-        request = posixpath.join( 'job', job, 'config.xml' )
+        request = posixpath.join('job', job, 'config.xml')
         params = None
-        headers = {'content-type' : 'application/xml'}
+        headers = {'content-type': 'application/xml'}
         try:
             self.get_job(job)
         except JenkinsError as e:
-            if e.code == 404: request = 'createItem'
+            if e.code == 404:
+                request = 'createItem'
             params = {'name': job}
 
-        if self.readonly: return None
+        if self.readonly:
+            return None
         put = self.post(request, data=config, params=params, headers=headers)
         return put
 
     def enable_job(self, job):
-        if self.readonly: return None
-        return self.post( posixpath.join( 'job', job, 'enable' ) );
+        if self.readonly:
+            return None
+        return self.post(posixpath.join('job', job, 'enable'))
 
     def disable_job(self, job):
-        if self.readonly: return None
-        return self.post( posixpath.join ( 'job', job, 'disable' ) );
+        if self.readonly:
+            return None
+        return self.post(posixpath.join('job', job, 'disable'))
 
     def delete_job(self, job):
-        if self.readonly: return None
-        return self.post( posixpath.join( 'job', job, 'doDelete' ) );
+        if self.readonly:
+            return None
+        return self.post(posixpath.join('job', job, 'doDelete'))
 
     def run_job(self, job, params=None):
-        if self.readonly: return None
+        if self.readonly:
+            return None
         if params == None:
-            response=self.post( posixpath.join( 'job', job, 'build') );
+            response = self.post(posixpath.join('job', job, 'build'))
         else:
-            response=self.post( posixpath.join( 'job', job, 'buildWithParameters' ), data=params)
+            response = self.post(posixpath.join('job', job, 'buildWithParameters'), data=params)
 
-        queue_item=QueueItem.from_jenkins_response(response, self)
+        queue_item = QueueItem.from_jenkins_response(response, self)
         return queue_item
 
-    def list_builds( self, node = None ):
+    def list_builds(self, node=None):
         """
         Get list of Builds which are currently build on the node given
         :param node: list only jobs building on the node specified
         :type node: string
         :return: dictionary with node_names as a key and list of jobs dictionaries building on the node as { "job_name": ... , "build_number" : ... }, list may be None
         """
-        str_request = "";
-        dict_parms = { "tree" : "jobs[name,lastBuild[building,fullDisplayName,number,url,builtOn]]" };
+        str_request = ""
+        dict_parms = {"tree": "jobs[name,lastBuild[building,fullDisplayName,number,url,builtOn]]"}
 
         if node is not None:
-            str_request = posixpath.join( "computer", node );
-            dict_parms[ "tree" ] = "executors[idle,currentExecutable[idle,building,builtOn,number,fullDisplayName,url]]";
+            str_request = posixpath.join("computer", node)
+            dict_parms["tree"] = "executors[idle,currentExecutable[idle,building,builtOn,number,fullDisplayName,url]]"
 
-        response = self.get( str_request, params = dict_parms );
-        dict_resp = json.loads( response.text );
+        response = self.get(str_request, params=dict_parms)
+        dict_resp = json.loads(response.text)
 
         if node is not None:
-            if len( dict_resp[ "executors" ] ) == 0:
-                return { node: list() };
+            if len(dict_resp["executors"]) == 0:
+                return {node: list()}
 
-            ls_jobs = map( lambda x: { "name" : None, "lastBuild" : ( None if x[ "idle" ] else x[ "currentExecutable" ] ) }, dict_resp[ "executors" ] );
-
-        else :
-            ls_jobs = dict_resp[ "jobs" ];
+            ls_jobs = map(lambda x: {"name": None, "lastBuild": (
+                None if x["idle"] else x["currentExecutable"])}, dict_resp["executors"])
 
+        else:
+            ls_jobs = dict_resp["jobs"]
 
-        dict_result = dict();
+        dict_result = dict()
 
         for dict_job in ls_jobs:
-            if "lastBuild" not in dict_job or dict_job[ "lastBuild" ] is None or not dict_job[ "lastBuild" ][ "building" ]:
-                continue; # inactive build, out of interes
+            if "lastBuild" not in dict_job or dict_job["lastBuild"] is None or not dict_job["lastBuild"]["building"]:
+                continue  # inactive build, out of interes
 
-            str_job_name = dict_job[ "name" ];
+            str_job_name = dict_job["name"]
 
             if not str_job_name:
-                str_job_name = dict_job[ "lastBuild" ][ "url" ].split( posixpath.sep + "job" + posixpath.sep, 1 )[1].split( posixpath.sep, 1 )[0];
+                str_job_name = dict_job["lastBuild"]["url"].split(
+                    posixpath.sep + "job" + posixpath.sep, 1)[1].split(posixpath.sep, 1)[0]
 
-            str_builder_node = dict_job[ "lastBuild" ][ "builtOn" ];
+            str_builder_node = dict_job["lastBuild"]["builtOn"]
 
             if str_builder_node not in dict_result:
-                dict_result[ str_builder_node ] = list();
+                dict_result[str_builder_node] = list()
 
-            dict_result[ str_builder_node ].append( { "job_name" : str_job_name, "build_nubmer" : dict_job[ "lastBuild" ][ "number" ] } );
+            dict_result[str_builder_node].append(
+                {"job_name": str_job_name, "build_nubmer": dict_job["lastBuild"]["number"]})
 
-        return dict_result;
+        return dict_result
 
-    def list_queue( self ):
+    def list_queue(self):
         """
         Get queue items, perhaps empty if no jobs queued
         :return: list of QueueItems, possible empty
         """
-        ls_result = list();
-        obj_resp = self.get( "queue" );
-        dict_resp = json.loads( obj_resp.text or {} );
+        ls_result = list()
+        obj_resp = self.get("queue")
+        dict_resp = json.loads(obj_resp.text or {})
 
         if not 'items' in dict_resp:
-            return ls_result;
+            return ls_result
 
-        for dict_task in dict_resp[ 'items' ]:
+        for dict_task in dict_resp['items']:
             if not 'task' in dict_task:
-                continue;
+                continue
 
-            if not 'name' in dict_task[ 'task' ]:
-                continue;
+            if not 'name' in dict_task['task']:
+                continue
 
             if not 'id' in dict_task:
-                continue;
+                continue
 
-            ls_result.append( QueueItem( dict_task[ 'id' ], self, dict_task ) );
-        
-        return ls_result;
+            ls_result.append(QueueItem(dict_task['id'], self, dict_task))
+
+        return ls_result
 
-    def unqueue_item( self, int_id ):
+    def unqueue_item(self, int_id):
         """
         remove item with ID given from queue
         :param int_id: id
         :type int_id: integer
         """
-        if int_id is None or not isinstance( int_id, int ):
-            raise TypeError( "Wrong type of arguments: int_id is not integer" );
+        if int_id is None or not isinstance(int_id, int):
+            raise TypeError("Wrong type of arguments: int_id is not integer")
 
         try:
-            self.post( posixpath.join( 'queue','cancelItem'), data = {}, params = { "id": int_id } );
+            self.post(posixpath.join('queue', 'cancelItem'), data={}, params={"id": int_id})
         except:
-            pass; # since jenkins returns 404 code for this type of operation and it is normal
+            pass  # since jenkins returns 404 code for this type of operation and it is normal
 
 
-from enum import Enum
 class BuildStatus(Enum):
-    BUILDING=0
-    SUCCESS=1
-    FAILURE=2
-    ABORTED=3
-    UNSTABLE=4
-    NOT_BUILD=5
+    BUILDING = 0
+    SUCCESS = 1
+    FAILURE = 2
+    ABORTED = 3
+    UNSTABLE = 4
+    NOT_BUILD = 5
 
 
 class Build(object):
     """
     Class designating launched build with known number.
     """
 
     def __init__(self, job_name, build_number, jenkins_client):
-        self.job_name=job_name
-        self.build_number=build_number
-        self.jenkins_client=jenkins_client
-        self._build_status=BuildStatus.BUILDING
+        self.job_name = job_name
+        self.build_number = build_number
+        self.jenkins_client = jenkins_client
+        self._build_status = BuildStatus.BUILDING
 
     def get_status(self):
         self._update_build_status()
         return self._build_status
 
     def _update_build_status(self):
-        if self._build_status!=BuildStatus.BUILDING:
+        if self._build_status != BuildStatus.BUILDING:
             return self._build_status
-        build_path = posixpath.join( "job", self.job_name, str( self.build_number ), 'api', 'json' )
-        response=self.jenkins_client.get(build_path)
-        if response.status_code==404:
+        build_path = posixpath.join("job", self.job_name, str(self.build_number), 'api', 'json')
+        response = self.jenkins_client.get(build_path)
+        if response.status_code == 404:
             raise JenkinsError("No build exist at %s" % build_path)
-        parsed_response=json.loads(response.text or "{}")
-        status_value=parsed_response["result"]
+        parsed_response = json.loads(response.text or "{}")
+        status_value = parsed_response["result"]
         if not status_value:
-            self._build_status=BuildStatus.BUILDING
+            self._build_status = BuildStatus.BUILDING
         else:
             if sys.version_info.major == 2:
                 self._build_status = getattr(BuildStatus, status_value)
             else:
-                self._build_status=BuildStatus[status_value]
+                self._build_status = BuildStatus[status_value]
 
 
 class QueueItem(object):
     """ 
     Class used to hold information about build request.
     Initially it only knows its queue id, which can be used to get concrete build later.
     """
 
     @classmethod
     def from_jenkins_response(cls, response, jenkins_client):
-        location_url=response.headers["Location"]
-        search_result=re.search( r'' + posixpath.join( "queue", "item", "(?P<queue_id>\d+)" ), location_url)
-        queue_id=int(search_result.group("queue_id"))
+        location_url = response.headers["Location"]
+        search_result = re.search(r'' + posixpath.join("queue", "item", "(?P<queue_id>\d+)"), location_url)
+        queue_id = int(search_result.group("queue_id"))
         return QueueItem(queue_id, jenkins_client)
-    
-    def __init__(self, queue_id, jenkins_client, dict_details = None):
+
+    def __init__(self, queue_id, jenkins_client, dict_details=None):
         """
         :param resource: id in build queue (assigned at build launch request)
         :param required: jenkins.Jenkins instance
         """
-        self.queue_id=queue_id
-        self.jenkins_client=jenkins_client
-        self._build=None
-        self._task=None;
+        self.queue_id = queue_id
+        self.jenkins_client = jenkins_client
+        self._build = None
+        self._task = None
 
         if not dict_details:
-            return;
+            return
 
         if "task" in dict_details:
-            self._task = dict_details[ "task" ];
+            self._task = dict_details["task"]
 
     @property
-    def task( self ):
+    def task(self):
         """
         :return: dictionary with task parameters - job name, url, color - as it returned by Jenkins
         """
         if not self._task:
-            self._try_update_queue_status();
-        return self._task;
+            self._try_update_queue_status()
+        return self._task
 
     @property
-    def job_name( self ):
+    def job_name(self):
         """
         :return: job name of the queue item
         """
 
         if not self._task:
-            self._try_update_queue_status();
+            self._try_update_queue_status()
 
         if not self._task:
-            return None;
+            return None
 
         if "url" not in self._task:
-            self._try_update_queue_status();
+            self._try_update_queue_status()
 
         if "url" not in self._task:
-            return None;
+            return None
 
-        return self._task[ "url" ].split( posixpath.sep + "job" + posixpath.sep, 1 )[1].split( posixpath.sep, 1 )[0];
+        return self._task["url"].split(posixpath.sep + "job" + posixpath.sep, 1).pop().split(posixpath.sep, 1).pop(0)
 
     def is_running(self):
         self._try_update_queue_status()
         return bool(self._build)
 
     def get_build(self):
         self._try_update_queue_status()
+
         if self._build:
             return self._build
-        else:
-            raise BuildStatusException("Build is not started yet")
+        
+        raise BuildStatusException("Build is not started yet")
 
     def _try_update_queue_status(self):
         if self._build:
             return
-        item_path= posixpath.join( "queue", "item", str( self.queue_id ), "api", "json" );
-        response=self.jenkins_client.get(item_path)
-        if response.status_code==404:
+        item_path = posixpath.join("queue", "item", str(self.queue_id), "api", "json")
+        response = self.jenkins_client.get(item_path)
+        if response.status_code == 404:
             raise JenkinsError("No queue item exist at %s" % item_path)
-        parsed_response=json.loads(response.text or "{}")
+        parsed_response = json.loads(response.text or "{}")
         if "executable" in parsed_response:
-            self._build=Build(parsed_response["task"]["name"],
-                              parsed_response["executable"]["number"],
-                              self.jenkins_client)
+            self._build = Build(parsed_response["task"]["name"],
+                                parsed_response["executable"]["number"],
+                                self.jenkins_client)
 
         if not self._task and "task" in parsed_response:
-            self._task = parsed_response[ "task" ];
-    
+            self._task = parsed_response["task"]
+
 
 class BuildStatusException(Exception):
     pass
 
-
-if __name__ == "__main__":
-    import doctest
-
-    doctest.testmod()
```

## oc_cdtapi/NexusAPI.py

```diff
@@ -242,16 +242,15 @@
         """
         Get full artifact URL.
         :param gav: gav
         :type gav: str, dict
         :param repo: repo
         :type repo: str
         """
-        # here is nice place to use 'urllib.urljoin'
-        # but implemented ugly via 'posixpath' to get rid of extra dependencies
+        #urllib.urlparse.urljoin is not suitable for us since it joins only host part + relative part
         if not gav:
             raise ValueError("GAV is mandatory")
 
         return posixpath.join(self.root, self.__gav_get_url(gav, repo=repo))
 
     def __gav_get_url(self, gav, repo, relaxed=False):
         """
```

## Comparing `oc_cdtapi-3.9.2.data/scripts/nexus.py` & `oc_cdtapi-3.9.4.data/scripts/nexus.py`

 * *Files identical despite different names*

## Comparing `oc_cdtapi-3.9.2.dist-info/LICENSE` & `oc_cdtapi-3.9.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `oc_cdtapi-3.9.2.dist-info/RECORD` & `oc_cdtapi-3.9.4.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-oc_cdtapi/API.py,sha256=ScjpCC6bdEzJBc1Qgp6ODH8bfxwccBr3hI9I96UYmQk,8680
-oc_cdtapi/DevPIAPI.py,sha256=SvQWSpsgZEsxJmm-edTPqZ25fi8KyvxQ0X27vjhU3cI,2054
-oc_cdtapi/DmsAPI.py,sha256=NzXfJ9k1srTOWZYCwOhxzLN1deNGnPtJoUy22qjiGmQ,7841
-oc_cdtapi/DmsGetverAPI.py,sha256=SOFLSl8DOCblR-swdHeufRLMPKahf1rDbILfz-4_zbk,13948
-oc_cdtapi/ForemanAPI.py,sha256=wGYPEPYgeNUSp2SATk_pZ4FRIwX9lmkcAgZyIzM47_4,39979
-oc_cdtapi/JenkinsAPI.py,sha256=ZBMDRmR4K7rlpGzqaWL7vPjlwweP4AGi2bom31v5T8s,15862
-oc_cdtapi/NexusAPI.py,sha256=PsE6Lzh3WcmZkqlIo0zqi_VvpHjYciUYvCLEQtH4bzw,26153
+oc_cdtapi/API.py,sha256=hpdnzyirYT_wISeznRmoqr-umYRT6uqKVwhmCXyj8Nk,12398
+oc_cdtapi/DevPIAPI.py,sha256=Nn63Ob0kA5XXuRZ3OIWG2rcnSsztKq9yPI6Lu2zX3Gk,1836
+oc_cdtapi/DmsAPI.py,sha256=j2Bx4Sryc4R1knyNjQmZshVuCePeD2q4W-fxv7zOMFc,9481
+oc_cdtapi/DmsGetverAPI.py,sha256=NIhWq2MDWaIBFLYJqkPCV9jZqM1HSZum6gIHquGHdQg,16085
+oc_cdtapi/ForemanAPI.py,sha256=FP_zeCgnSSYTPPck_xD0GsYH5BD0nLiOTiG1Qj4OkO8,39747
+oc_cdtapi/JenkinsAPI.py,sha256=lZ8pe3a4eb_6h53JE7QLuzOSlu7Sqatc9PQwWhio9Vg,15748
+oc_cdtapi/NexusAPI.py,sha256=uU12GtHvKlWorFaPAnFcQ5AGEc94MZ5SdmfM2Pw3F7A,26122
 oc_cdtapi/TestServer.py,sha256=HV97UWg2IK4gOYAp9yaMdwFUWsw9v66MxyZdI3qQctA,2715
 oc_cdtapi/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-oc_cdtapi-3.9.2.data/scripts/nexus.py,sha256=4teqZ_KtCSrwHDJVgA7lkreteod4Xt5XJFZNbwb7E6E,6858
-oc_cdtapi-3.9.2.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-oc_cdtapi-3.9.2.dist-info/METADATA,sha256=vvaNt2GXOnNYqCH8Pc6sHtIBI_XVCqZo34pk43zB9nQ,276
-oc_cdtapi-3.9.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-oc_cdtapi-3.9.2.dist-info/top_level.txt,sha256=d4-5-D-0CSeSXYuLCP7-nIFCpjkfmJr-Y_muzds8iVU,10
-oc_cdtapi-3.9.2.dist-info/RECORD,,
+oc_cdtapi-3.9.4.data/scripts/nexus.py,sha256=4teqZ_KtCSrwHDJVgA7lkreteod4Xt5XJFZNbwb7E6E,6858
+oc_cdtapi-3.9.4.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+oc_cdtapi-3.9.4.dist-info/METADATA,sha256=lNhBYahN9k9O2JftxqoGLirm50Pca2vWhxxPUz_1y98,276
+oc_cdtapi-3.9.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+oc_cdtapi-3.9.4.dist-info/top_level.txt,sha256=d4-5-D-0CSeSXYuLCP7-nIFCpjkfmJr-Y_muzds8iVU,10
+oc_cdtapi-3.9.4.dist-info/RECORD,,
```

