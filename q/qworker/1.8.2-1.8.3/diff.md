# Comparing `tmp/qworker-1.8.2-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/qworker-1.8.3-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,37 +1,37 @@
-Zip file size: 317241 bytes, number of entries: 35
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qw/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qworker.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qworker-1.8.2.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qw/wrappers/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qw/utils/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qw/queues/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 15:41 qw/executor/
--rw-r--r--  2.0 unx      137 b- defN 23-Jun-05 15:41 qw/__init__.py
--rw-r--r--  2.0 unx      622 b- defN 23-Jun-05 15:41 qw/version.py
--rw-r--r--  2.0 unx     7462 b- defN 23-Jun-05 15:41 qw/process.py
--rw-r--r--  2.0 unx     2728 b- defN 23-Jun-05 15:41 qw/conf.py
--rw-r--r--  2.0 unx     4129 b- defN 23-Jun-05 15:41 qw/protocols.py
--rw-r--r--  2.0 unx     2392 b- defN 23-Jun-05 15:41 qw/__main__.py
--rwxr-xr-x  2.0 unx   568544 b- defN 23-Jun-05 15:41 qw/exceptions.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx    15767 b- defN 23-Jun-05 15:41 qw/client.py
--rw-r--r--  2.0 unx    15872 b- defN 23-Jun-05 15:41 qw/server.py
--rw-r--r--  2.0 unx     2160 b- defN 23-Jun-05 15:41 qw/discovery.py
--rw-r--r--  2.0 unx      380 b- defN 23-Jun-05 15:41 qw/decorators.py
--rw-r--r--  2.0 unx      320 b- defN 23-Jun-05 15:41 qw/wrappers/__init__.py
--rw-r--r--  2.0 unx     4315 b- defN 23-Jun-05 15:41 qw/wrappers/di_task.py
--rw-r--r--  2.0 unx     1447 b- defN 23-Jun-05 15:41 qw/wrappers/base.py
--rw-r--r--  2.0 unx     1246 b- defN 23-Jun-05 15:41 qw/wrappers/func.py
--rw-r--r--  2.0 unx      597 b- defN 23-Jun-05 15:41 qw/utils/versions.py
--rw-r--r--  2.0 unx       46 b- defN 23-Jun-05 15:41 qw/utils/__init__.py
--rw-r--r--  2.0 unx      512 b- defN 23-Jun-05 15:41 qw/utils/functions.py
--rwxr-xr-x  2.0 unx   434800 b- defN 23-Jun-05 15:41 qw/utils/json.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx       62 b- defN 23-Jun-05 15:41 qw/queues/__init__.py
--rw-r--r--  2.0 unx     5915 b- defN 23-Jun-05 15:41 qw/queues/manager.py
--rw-r--r--  2.0 unx     1849 b- defN 23-Jun-05 15:41 qw/executor/__init__.py
--rw-r--r--  2.0 unx     3170 b- defN 23-Jun-05 15:41 qworker-1.8.2.dist-info/METADATA
--rw-r--r--  2.0 unx     1070 b- defN 23-Jun-05 15:41 qworker-1.8.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx     2189 b- defN 23-Jun-05 15:41 qworker-1.8.2.dist-info/RECORD
--rw-r--r--  2.0 unx       40 b- defN 23-Jun-05 15:41 qworker-1.8.2.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        3 b- defN 23-Jun-05 15:41 qworker-1.8.2.dist-info/top_level.txt
--rw-r--r--  2.0 unx      217 b- defN 23-Jun-05 15:41 qworker-1.8.2.dist-info/WHEEL
-35 files, 1077991 bytes uncompressed, 313135 bytes compressed:  71.0%
+Zip file size: 317362 bytes, number of entries: 35
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qw/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qworker.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qworker-1.8.3.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qw/wrappers/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qw/utils/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qw/queues/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-05 16:14 qw/executor/
+-rw-r--r--  2.0 unx      137 b- defN 23-Jun-05 16:14 qw/__init__.py
+-rw-r--r--  2.0 unx      622 b- defN 23-Jun-05 16:14 qw/version.py
+-rw-r--r--  2.0 unx     7462 b- defN 23-Jun-05 16:14 qw/process.py
+-rw-r--r--  2.0 unx     2728 b- defN 23-Jun-05 16:14 qw/conf.py
+-rw-r--r--  2.0 unx     4129 b- defN 23-Jun-05 16:14 qw/protocols.py
+-rw-r--r--  2.0 unx     2392 b- defN 23-Jun-05 16:14 qw/__main__.py
+-rwxr-xr-x  2.0 unx   568544 b- defN 23-Jun-05 16:14 qw/exceptions.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx    16261 b- defN 23-Jun-05 16:14 qw/client.py
+-rw-r--r--  2.0 unx    15912 b- defN 23-Jun-05 16:14 qw/server.py
+-rw-r--r--  2.0 unx     2160 b- defN 23-Jun-05 16:14 qw/discovery.py
+-rw-r--r--  2.0 unx      380 b- defN 23-Jun-05 16:14 qw/decorators.py
+-rw-r--r--  2.0 unx      320 b- defN 23-Jun-05 16:14 qw/wrappers/__init__.py
+-rw-r--r--  2.0 unx     4315 b- defN 23-Jun-05 16:14 qw/wrappers/di_task.py
+-rw-r--r--  2.0 unx     1447 b- defN 23-Jun-05 16:14 qw/wrappers/base.py
+-rw-r--r--  2.0 unx     1246 b- defN 23-Jun-05 16:14 qw/wrappers/func.py
+-rw-r--r--  2.0 unx      597 b- defN 23-Jun-05 16:14 qw/utils/versions.py
+-rw-r--r--  2.0 unx       46 b- defN 23-Jun-05 16:14 qw/utils/__init__.py
+-rw-r--r--  2.0 unx      512 b- defN 23-Jun-05 16:14 qw/utils/functions.py
+-rwxr-xr-x  2.0 unx   434800 b- defN 23-Jun-05 16:14 qw/utils/json.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx       62 b- defN 23-Jun-05 16:14 qw/queues/__init__.py
+-rw-r--r--  2.0 unx     5783 b- defN 23-Jun-05 16:14 qw/queues/manager.py
+-rw-r--r--  2.0 unx     1849 b- defN 23-Jun-05 16:14 qw/executor/__init__.py
+-rw-r--r--  2.0 unx     3170 b- defN 23-Jun-05 16:14 qworker-1.8.3.dist-info/METADATA
+-rw-r--r--  2.0 unx     1070 b- defN 23-Jun-05 16:14 qworker-1.8.3.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     2189 b- defN 23-Jun-05 16:14 qworker-1.8.3.dist-info/RECORD
+-rw-r--r--  2.0 unx       40 b- defN 23-Jun-05 16:14 qworker-1.8.3.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        3 b- defN 23-Jun-05 16:14 qworker-1.8.3.dist-info/top_level.txt
+-rw-r--r--  2.0 unx      217 b- defN 23-Jun-05 16:14 qworker-1.8.3.dist-info/WHEEL
+35 files, 1078393 bytes uncompressed, 313256 bytes compressed:  71.0%
```

## zipnote {}

```diff
@@ -1,14 +1,14 @@
 Filename: qw/
 Comment: 
 
 Filename: qworker.libs/
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/
+Filename: qworker-1.8.3.dist-info/
 Comment: 
 
 Filename: qw/wrappers/
 Comment: 
 
 Filename: qw/utils/
 Comment: 
@@ -81,26 +81,26 @@
 
 Filename: qw/queues/manager.py
 Comment: 
 
 Filename: qw/executor/__init__.py
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/METADATA
+Filename: qworker-1.8.3.dist-info/METADATA
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/LICENSE
+Filename: qworker-1.8.3.dist-info/LICENSE
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/RECORD
+Filename: qworker-1.8.3.dist-info/RECORD
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/entry_points.txt
+Filename: qworker-1.8.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/top_level.txt
+Filename: qworker-1.8.3.dist-info/top_level.txt
 Comment: 
 
-Filename: qworker-1.8.2.dist-info/WHEEL
+Filename: qworker-1.8.3.dist-info/WHEEL
 Comment: 
 
 Zip file comment:
```

## qw/version.py

```diff
@@ -2,15 +2,15 @@
    QueueWorker is a asyncio-based Worker for distributed functions.
 """
 
 __title__ = 'qworker'
 __description__ = ('QueueWorker is asynchronous Task Queue implementation '
                    'built on top of Asyncio.'
                    'Can you spawn distributed workers to run functions inside workers.')
-__version__ = '1.8.2'
+__version__ = '1.8.3'
 __author__ = 'Jesus Lara'
 __author_email__ = 'jesuslarag@gmail.com'
 __license__ = 'MIT'
 
 def get_version() -> tuple:  # pragma: no cover
     """ Get Queue Worker version as tuple.
     """
```

## qw/client.py

```diff
@@ -1,15 +1,15 @@
 """QueueWorker Client."""
 import asyncio
 import itertools
 import random
 import warnings
 import inspect
-from typing import Any
-from collections.abc import Callable
+from typing import Any, Union
+from collections.abc import Callable, Awaitable
 from collections import defaultdict
 from functools import partial
 import aioredis
 import pickle
 import cloudpickle
 import jsonpickle
 import orjson
@@ -237,104 +237,150 @@
             if self.redis:
                 await self.redis.disconnect(inuse_connections=True)
         except (AttributeError, ConnectionError) as err:
             self.logger.error(err)
         self.logger.debug('Closing Socket')
         writer.close()
 
-    async def run(self, fn: Any, *args, use_wrapper: bool = False, **kwargs):
-        """Runs a function in Queue Worker
-
-        Run function in the Queue Worker, returns the result or raises exception.
-
-        Args:
-            fn: Any Function, object or callable to be send to Worker.
-            args: any non-keyword arguments
-            use_wrapper: (bool) wraps function into a Function Wrapper.
-            kwargs: keyword arguments.
-
-        Returns:
-            Function Result.
-
-        Raises:
-            ConfigError: bad instructions to Worker Client.
-            ConnectionError: unable to connect to Worker.
-            Exception: Any Unhandled error.
-        """
+    async def get_worker_connection(self):
         try:
             reader, writer = await self.get_connection()
+            return reader, writer
         except DiscardedTask:
             await asyncio.sleep(WAIT_TIME)
             ### ask again after wait for new connection:
             reader, writer = await self.get_connection()
+            return reader, writer
         except ConnectionError as ex:
             raise ConnectionError(
                 f"Unable to Connect to Queue Worker: {ex}"
             ) from ex
         except Exception as err:
             self.logger.error(err)
             raise
 
-        host, *_ = writer.get_extra_info('sockname')
-        # wrapping the function into Task Wrapper
-        self.logger.debug(f'Sending Object {fn!s} to Worker {host}')
-        if isinstance(fn, (TaskWrapper, FuncWrapper)):
-            # already wrapped
-            func = fn
-            func.queued = False
-        elif use_wrapper is True:
-            # wrap function into a Wrapper:
-            func = FuncWrapper(
-                host,
-                fn,
-                *args,
-                **kwargs
-            )
-            func.queued = False
-        else:
-            # sent function *as is*
-            func = partial(fn, *args, **kwargs)
+    async def sendto_worker(
+        self,
+        func: Union[Callable, Awaitable],
+        writer: asyncio.StreamWriter
+    ):
+        serialized_task = None
         try:
             serialized_task = cloudpickle.dumps(func)
             writer.write(serialized_task)
             # sending data to worker:
             if writer.can_write_eof():
                 writer.write_eof()
             await writer.drain()
         except Exception as err:
-            self.logger.error(f'Error Serializing Task: {err!s}')
+            self.logger.error(
+                f'Error Serializing Task {func!r}: {err!s}'
+            )
             raise
-        # Then, got the result:
-        serialized_result = None
+        return serialized_task
+
+    async def get_result(
+        self,
+        reader: asyncio.StreamReader,
+        writer: asyncio.StreamWriter
+    ):
+        result = None
         try:
             while True:
-                serialized_result = await reader.read(-1)
+                result = await reader.read(-1)
                 if reader.at_eof():
                     break
         except Exception as ex:
             raise QWException(
                 f"Error getting results from Worker: {ex}"
             ) from ex
         finally:
             await self.close(writer)
+            return result
+
+    def get_wrapped_function(
+        self,
+        fn: Any,
+        host: str,
+        *args,
+        use_wrapper: bool = False,
+        queued: bool = False,
+        **kwargs
+    ):
+        if isinstance(fn, (TaskWrapper, FuncWrapper)):
+            # already wrapped
+            func = fn
+            func.queued = queued
+        elif use_wrapper is True:
+            # wrap function into a Wrapper:
+            func = FuncWrapper(
+                host,
+                fn,
+                *args,
+                **kwargs
+            )
+            func.queued = queued
+        else:
+            # sent function *as is* using partial
+            func = partial(fn, *args, **kwargs)
+        return func
+
+    async def run(self, fn: Any, *args, use_wrapper: bool = False, **kwargs):
+        """Runs a function in Queue Worker
+
+        Run function in the Queue Worker, returns the result or raises exception.
+
+        Args:
+            fn: Any Function, object or callable to be send to Worker.
+            args: any non-keyword arguments
+            use_wrapper: (bool) wraps function into a Function Wrapper.
+            kwargs: keyword arguments.
+
+        Returns:
+            Function Result.
+
+        Raises:
+            ConfigError: bad instructions to Worker Client.
+            ConnectionError: unable to connect to Worker.
+            Exception: Any Unhandled error.
+        """
+        reader, writer = await self.get_worker_connection()
+
+        host, *_ = writer.get_extra_info('sockname')
+        # wrapping the function into Task Wrapper
+        self.logger.debug(
+            f'Sending Object {fn!s} to Worker {host}'
+        )
+        func = self.get_wrapped_function(
+            fn,
+            host,
+            *args,
+            use_wrapper=use_wrapper,
+            queued=False,
+            **kwargs
+        )
+        ## send data to worker:
+        await self.sendto_worker(func, writer)
+        # Then, got the result:
+        serialized_result = await self.get_result(reader, writer)
         try:
             task_result = cloudpickle.loads(serialized_result)
             self.logger.debug(
                 f'Data Received: {task_result!r}'
             )
             try:
                 if isinstance(task_result, str):
                     result = jsonpickle.decode(task_result)
                 else:
                     result = task_result
             except (TypeError, ValueError) as e:
-                print(e)
+                logging.error(e)
                 result = task_result
             except Exception as e:
-                print(e)
+                logging.error(e)
             task_result = result
         except (ValueError, TypeError) as ex:
             raise ParserError(
                 f"Error Parsing serialized results: {ex}"
             ) from ex
         except EOFError as err:
             self.logger.exception(f'No data was received from Server: {err!s}')
@@ -368,15 +414,15 @@
                     raise ex(
                         f"{error}: {msg}"
                     )
             return task_result
         else:
             return task_result
 
-    async def queue(self, fn: Any, *args, **kwargs):
+    async def queue(self, fn: Any, *args, use_wrapper: bool = True, **kwargs):
         """Send a function to a Queue Worker and return.
 
         Send & Forget functionality to send a task to Queue Worker.
 
         Args:
             fn: Any Function, object or callable to be send to Worker.
             args: any non-keyword arguments
@@ -387,47 +433,31 @@
 
         Raises:
             ConfigError: bad instructions to Worker Client.
             ConnectionError: unable to connect to Worker.
             Exception: Any Unhandled error.
         """
         # TODO: Use Task id to return (later) the result of Task.
-        try:
-            reader, writer = await self.get_connection()
-        except DiscardedTask:
-            await asyncio.sleep(WAIT_TIME)
-            ### ask again after wait for new connection:
-            reader, writer = await self.get_connection()
-        except Exception as err:
-            self.logger.error(err)
-            raise
-        self.logger.debug(f'Sending function {fn!s} to Worker')
+        reader, writer = await self.get_worker_connection()
+        self.logger.debug(
+            f'Sending function {fn!s} to Worker'
+        )
         host, *_ = writer.get_extra_info('sockname')
-        if isinstance(fn, (FuncWrapper, TaskWrapper)):
-            # Function was wrapped or is already wrapped
-            func = fn
-        elif not asyncio.iscoroutinefunction(fn):
-            func = fn(*args, **kwargs)
-        else:
-            func = FuncWrapper(
-                host,
-                fn,
-                *args,
-                **kwargs
-            )
         # serializing
-        print('FN: ', func, func.__class__.__name__)
+        func = self.get_wrapped_function(
+            fn,
+            host,
+            *args,
+            use_wrapper=use_wrapper,
+            queued=True,
+            **kwargs
+        )
         try:
-            # getting data
-            serialized_task = cloudpickle.dumps(func)
-            writer.write(serialized_task)
-            # sending data to worker:
-            if writer.can_write_eof():
-                writer.write_eof()
-            await writer.drain()
+            ## send data to worker:
+            await self.sendto_worker(func, writer=writer)
             # asks server if task was queued:
             try:
                 while True:
                     serialized_result = await reader.read(-1)
                     if reader.at_eof():
                         break
             except Exception as err:
```

## qw/server.py

```diff
@@ -297,15 +297,16 @@
     async def deserialize_task(self, serialized_task, writer: asyncio.StreamWriter):
         try:
             task = cloudpickle.loads(serialized_task)
             self.logger.debug(
                 f'TASK RECEIVED: {task} at {int(time.time())}'
             )
             return task
-        except RuntimeError as ex:
+        except (EOFError, RuntimeError) as ex:
+            ### Empty Task:
             ex = ParserError(
                 f"Error Decoding Serialized Task: {ex}"
             )
             result = cloudpickle.dumps(ex)
             await self.closing_writer(writer, result)
             return False
```

## qw/queues/manager.py

```diff
@@ -161,16 +161,14 @@
             except Exception as exc:
                 self.logger.error(
                     f"Task failed with error: {exc}"
                 )
                 raise
             finally:
                 ### Task Completed
-                print('============== LLEGA AQUI ==============')
                 self.queue.task_done()
-                print('============== LLEGA AQUI ==============')
                 await self._callback(
                     task, result=result
                 )
             self.logger.debug(
                 f'QUEUE Size after Work: {self.queue.qsize()}'
             )
```

## Comparing `qworker-1.8.2.dist-info/METADATA` & `qworker-1.8.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: qworker
-Version: 1.8.2
+Version: 1.8.3
 Summary: QueueWorker is asynchronous Task Queue implementation built on top of Asyncio.Can you spawn distributed workers to run functions inside workers.
 Home-page: https://github.com/phenobarbital/qworker
 Author: Jesus Lara
 Author-email: jesuslara@phenobarbital.info
 License: MIT
 Project-URL: Source, https://github.com/phenobarbital/qworker
 Project-URL: Funding, https://paypal.me/phenobarbital
```

## Comparing `qworker-1.8.2.dist-info/LICENSE` & `qworker-1.8.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `qworker-1.8.2.dist-info/RECORD` & `qworker-1.8.3.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 qw/__init__.py,sha256=awMNjg7WGznbrNuJLoEJV6BbnREk4BPD8k9My8BD7Uo,137
-qw/version.py,sha256=CzzT6nCACAc7P7HoMaR6f_dQqkXUGfn9WHpylyZr2sM,622
+qw/version.py,sha256=4F4x-grVnJlgTDkg8WJ6OE_-SntaSazjyZopsYQkexQ,622
 qw/process.py,sha256=Mbd-zlYS8oefzxpiMnWw-LziBj6hiZXu2uQT6yySmuw,7462
 qw/conf.py,sha256=pNnu0I15cOZYPFyQN5xQ2LFqlAIRoQeDDJcwIEAmbKA,2728
 qw/protocols.py,sha256=I57MsY72OlVlGFT1-ggZCm4nWAd89m4m5YEwGUWGAmg,4129
 qw/__main__.py,sha256=oUCTmeloFK83is_ipZ3yoRreu23TIcAELKhpOiIt_Xc,2392
 qw/exceptions.cpython-39-x86_64-linux-gnu.so,sha256=31p1G11akVAHtoIku71L-pdOUKnmz0rZrK3glmOCQ9A,568544
-qw/client.py,sha256=OzH8FQpm2f2FgRbQ4D8UNxh4tjai-I3JMQWa6rNAYdg,15767
-qw/server.py,sha256=OeELDDLH-l3aE3zaoLa9dhO3U2ypmS_Pi738d4EyrDc,15872
+qw/client.py,sha256=-JRd9E6v0bUeUuLH-2a2WLfLujkQW6AWnEEbYoTZWPc,16261
+qw/server.py,sha256=5DbMxJ1TzERfeK59Uxpn_3_-ieekGxXTakWo9W4BgYk,15912
 qw/discovery.py,sha256=l_Lb3Bmni6WTTu5fxzj4-9KquiRak1rq8k9I70f_hSI,2160
 qw/decorators.py,sha256=lL5CN9a7gUi8iDEfOI7kSpABkScu5cE99yj9eYGn69w,380
 qw/wrappers/__init__.py,sha256=Ot_f0GTaDB50Za4Hxsz2FZSkZDn4zZoDHjXOvqj9T9k,320
 qw/wrappers/di_task.py,sha256=rjxsQfOeAd_awocCx6st8e0-J4bFLMamUCi98F5jpTM,4315
 qw/wrappers/base.py,sha256=FeeaDDGLZH1Q6PN4dxlshBHSB5fMGEoVXRrhQB3xtBA,1447
 qw/wrappers/func.py,sha256=sL43tB6BWPbz-iOpkySTaOIpGtd6J1F37R8V7WfwcE8,1246
 qw/utils/versions.py,sha256=d8AdLmhM1bPc82vTAshCJBljGr-Ur3_hiZ_GtTbbORA,597
 qw/utils/__init__.py,sha256=bYf_I4ymTf8vsqMjK00NJi2-A-lVijPTwN6HDOVjcjQ,46
 qw/utils/functions.py,sha256=9iXVvYLtQzOK0tRecOV2Oqrl-2raxAHwBCNilLui1xQ,512
 qw/utils/json.cpython-39-x86_64-linux-gnu.so,sha256=cL7bP26M2Hib8DD0QMRY-AL6izzzBUWrJxxWHbIEkhA,434800
 qw/queues/__init__.py,sha256=itGqt8q7feqZePbUWJTeA82Q2AwU0B2agUFXRmpLuDc,62
-qw/queues/manager.py,sha256=7LZRa31olOAranMvzIW43-lyD_tZBgaLWf4MANeBjCI,5915
+qw/queues/manager.py,sha256=SJ4N9yd7CK-MvaDnfHVAGgu3iFWSta7EfVhDs5lIRtI,5783
 qw/executor/__init__.py,sha256=iJ-0XXC3zaf2HUFHAp6Vfwa-XYtFxyULU-WMDZZWxZM,1849
-qworker-1.8.2.dist-info/METADATA,sha256=ZjHkVRBzD_2DhYTEnDQpIZvhQk8sP4nD_6_oPcQ3cXs,3170
-qworker-1.8.2.dist-info/LICENSE,sha256=EW8vB8vWRFvBxGC3soG2HCxkuNrQpOGUgNFd81h7u54,1070
-qworker-1.8.2.dist-info/RECORD,,
-qworker-1.8.2.dist-info/entry_points.txt,sha256=ooHTYYyEjHI9Rj79mHQmU_s4HP-PTvD3g3xSa26vIGc,40
-qworker-1.8.2.dist-info/top_level.txt,sha256=2NxbFCeI_G1kzzf628VnbDchanCX6rcTJORdENY-rHI,3
-qworker-1.8.2.dist-info/WHEEL,sha256=G1-Tt_WO10x9oXjmzv4wXxMLbyVnQaK1ig1QydJbPuA,217
+qworker-1.8.3.dist-info/METADATA,sha256=VArcd6-rJGV5CNYsDs8nXx9At5XyRu8VMBs4Qk8a1mM,3170
+qworker-1.8.3.dist-info/LICENSE,sha256=EW8vB8vWRFvBxGC3soG2HCxkuNrQpOGUgNFd81h7u54,1070
+qworker-1.8.3.dist-info/RECORD,,
+qworker-1.8.3.dist-info/entry_points.txt,sha256=ooHTYYyEjHI9Rj79mHQmU_s4HP-PTvD3g3xSa26vIGc,40
+qworker-1.8.3.dist-info/top_level.txt,sha256=2NxbFCeI_G1kzzf628VnbDchanCX6rcTJORdENY-rHI,3
+qworker-1.8.3.dist-info/WHEEL,sha256=G1-Tt_WO10x9oXjmzv4wXxMLbyVnQaK1ig1QydJbPuA,217
```

