# Comparing `tmp/cubelib-1.0.5rc2-py3-none-any.whl.zip` & `tmp/cubelib-1.0.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,30 @@
-Zip file size: 39121 bytes, number of entries: 25
--rw-r--r--  2.0 unx      218 b- defN 23-Mar-30 11:50 cubelib/__init__.py
--rw-r--r--  2.0 unx      161 b- defN 23-Mar-30 11:50 cubelib/enums.py
--rw-r--r--  2.0 unx      376 b- defN 23-Mar-30 11:50 cubelib/errors.py
--rw-r--r--  2.0 unx      611 b- defN 23-Mar-30 11:50 cubelib/iautil.py
--rw-r--r--  2.0 unx    16297 b- defN 23-Mar-30 11:50 cubelib/mcsr.py
--rw-r--r--  2.0 unx    11621 b- defN 23-Mar-30 11:50 cubelib/p.py
--rw-r--r--  2.0 unx     8973 b- defN 23-Mar-30 11:50 cubelib/types.py
--rw-r--r--  2.0 unx       50 b- defN 23-Mar-30 11:50 cubelib/aio/__init__.py
--rw-r--r--  2.0 unx     2656 b- defN 23-Mar-30 11:50 cubelib/aio/aio.py
--rw-r--r--  2.0 unx       57 b- defN 23-Mar-30 11:50 cubelib/proto/__init__.py
--rw-r--r--  2.0 unx      203 b- defN 23-Mar-30 11:50 cubelib/proto/v340/ClientBound.py
--rw-r--r--  2.0 unx      299 b- defN 23-Mar-30 11:50 cubelib/proto/v340/ServerBound.py
--rw-r--r--  2.0 unx      105 b- defN 23-Mar-30 11:50 cubelib/proto/v340/__init__.py
--rw-r--r--  2.0 unx    11284 b- defN 23-Mar-30 11:50 cubelib/proto/v47/ClientBound.py
--rw-r--r--  2.0 unx     3695 b- defN 23-Mar-30 11:50 cubelib/proto/v47/ServerBound.py
--rw-r--r--  2.0 unx      103 b- defN 23-Mar-30 11:50 cubelib/proto/v47/__init__.py
--rw-r--r--  2.0 unx      813 b- defN 23-Mar-30 11:50 cubelib/proto/version_independent/ClientBound.py
--rw-r--r--  2.0 unx      847 b- defN 23-Mar-30 11:50 cubelib/proto/version_independent/ServerBound.py
--rw-r--r--  2.0 unx       88 b- defN 23-Mar-30 11:50 cubelib/proto/version_independent/__init__.py
--rw-rw-rw-  2.0 unx    35063 b- defN 23-Mar-30 11:50 cubelib-1.0.5rc2.dist-info/LICENSE
--rw-r--r--  2.0 unx     1559 b- defN 23-Mar-30 11:50 cubelib-1.0.5rc2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-30 11:50 cubelib-1.0.5rc2.dist-info/WHEEL
--rw-r--r--  2.0 unx       51 b- defN 23-Mar-30 11:50 cubelib-1.0.5rc2.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        8 b- defN 23-Mar-30 11:50 cubelib-1.0.5rc2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2077 b- defN 23-Mar-30 11:50 cubelib-1.0.5rc2.dist-info/RECORD
-25 files, 97307 bytes uncompressed, 35749 bytes compressed:  63.3%
+Zip file size: 48594 bytes, number of entries: 28
+-rw-r--r--  2.0 unx      278 b- defN 23-Jun-05 15:58 cubelib/__init__.py
+-rw-r--r--  2.0 unx      161 b- defN 23-Jun-05 15:58 cubelib/enums.py
+-rw-r--r--  2.0 unx      892 b- defN 23-Jun-05 15:58 cubelib/errors.py
+-rw-r--r--  2.0 unx      611 b- defN 23-Jun-05 15:58 cubelib/iautil.py
+-rw-r--r--  2.0 unx     2032 b- defN 23-Jun-05 15:58 cubelib/mcenums.py
+-rw-r--r--  2.0 unx    16297 b- defN 23-Jun-05 15:58 cubelib/mcsr.py
+-rw-r--r--  2.0 unx    12173 b- defN 23-Jun-05 15:58 cubelib/p.py
+-rw-r--r--  2.0 unx    21651 b- defN 23-Jun-05 15:58 cubelib/types.py
+-rw-r--r--  2.0 unx       50 b- defN 23-Jun-05 15:58 cubelib/aio/__init__.py
+-rw-r--r--  2.0 unx     2656 b- defN 23-Jun-05 15:58 cubelib/aio/aio.py
+-rw-r--r--  2.0 unx       57 b- defN 23-Jun-05 15:58 cubelib/proto/__init__.py
+-rw-r--r--  2.0 unx      203 b- defN 23-Jun-05 15:58 cubelib/proto/v340/ClientBound.py
+-rw-r--r--  2.0 unx      299 b- defN 23-Jun-05 15:58 cubelib/proto/v340/ServerBound.py
+-rw-r--r--  2.0 unx      105 b- defN 23-Jun-05 15:58 cubelib/proto/v340/__init__.py
+-rw-r--r--  2.0 unx    11828 b- defN 23-Jun-05 15:58 cubelib/proto/v47/ClientBound.py
+-rw-r--r--  2.0 unx     4150 b- defN 23-Jun-05 15:58 cubelib/proto/v47/ServerBound.py
+-rw-r--r--  2.0 unx      124 b- defN 23-Jun-05 15:58 cubelib/proto/v47/__init__.py
+-rw-r--r--  2.0 unx    12408 b- defN 23-Jun-05 15:58 cubelib/proto/v47/enums.py
+-rw-r--r--  2.0 unx     4422 b- defN 23-Jun-05 15:58 cubelib/proto/v47/types.py
+-rw-r--r--  2.0 unx      813 b- defN 23-Jun-05 15:58 cubelib/proto/version_independent/ClientBound.py
+-rw-r--r--  2.0 unx      847 b- defN 23-Jun-05 15:58 cubelib/proto/version_independent/ServerBound.py
+-rw-r--r--  2.0 unx       88 b- defN 23-Jun-05 15:58 cubelib/proto/version_independent/__init__.py
+-rw-rw-rw-  2.0 unx    35063 b- defN 23-Jun-05 15:58 cubelib-1.0.7.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1556 b- defN 23-Jun-05 15:58 cubelib-1.0.7.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-05 15:58 cubelib-1.0.7.dist-info/WHEEL
+-rw-r--r--  2.0 unx       51 b- defN 23-Jun-05 15:58 cubelib-1.0.7.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        8 b- defN 23-Jun-05 15:58 cubelib-1.0.7.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2302 b- defN 23-Jun-05 15:58 cubelib-1.0.7.dist-info/RECORD
+28 files, 131217 bytes uncompressed, 44890 bytes compressed:  65.8%
```

## zipnote {}

```diff
@@ -6,14 +6,17 @@
 
 Filename: cubelib/errors.py
 Comment: 
 
 Filename: cubelib/iautil.py
 Comment: 
 
+Filename: cubelib/mcenums.py
+Comment: 
+
 Filename: cubelib/mcsr.py
 Comment: 
 
 Filename: cubelib/p.py
 Comment: 
 
 Filename: cubelib/types.py
@@ -42,35 +45,41 @@
 
 Filename: cubelib/proto/v47/ServerBound.py
 Comment: 
 
 Filename: cubelib/proto/v47/__init__.py
 Comment: 
 
+Filename: cubelib/proto/v47/enums.py
+Comment: 
+
+Filename: cubelib/proto/v47/types.py
+Comment: 
+
 Filename: cubelib/proto/version_independent/ClientBound.py
 Comment: 
 
 Filename: cubelib/proto/version_independent/ServerBound.py
 Comment: 
 
 Filename: cubelib/proto/version_independent/__init__.py
 Comment: 
 
-Filename: cubelib-1.0.5rc2.dist-info/LICENSE
+Filename: cubelib-1.0.7.dist-info/LICENSE
 Comment: 
 
-Filename: cubelib-1.0.5rc2.dist-info/METADATA
+Filename: cubelib-1.0.7.dist-info/METADATA
 Comment: 
 
-Filename: cubelib-1.0.5rc2.dist-info/WHEEL
+Filename: cubelib-1.0.7.dist-info/WHEEL
 Comment: 
 
-Filename: cubelib-1.0.5rc2.dist-info/entry_points.txt
+Filename: cubelib-1.0.7.dist-info/entry_points.txt
 Comment: 
 
-Filename: cubelib-1.0.5rc2.dist-info/top_level.txt
+Filename: cubelib-1.0.7.dist-info/top_level.txt
 Comment: 
 
-Filename: cubelib-1.0.5rc2.dist-info/RECORD
+Filename: cubelib-1.0.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cubelib/__init__.py

```diff
@@ -1,11 +1,11 @@
 from cubelib.enums import state, bound
-from cubelib.types import NextState
+from cubelib.types import NextState # deprecated. removal release: 1.1.x. use cubelib.state instead!
 from cubelib.p import readPacketsStream, rrPacketsStream
 from . import proto
 
-version = '1.0.5-pre2'
+version = '1.0.7'
 
 supported_versions = [
     47,
     340
 ]
```

## cubelib/errors.py

```diff
@@ -1,17 +1,26 @@
 class BufferExhaustedException(Exception):
     """
         Raised when buffer read() returned less than need
+        RATE on L1: Placebo (automatic skipping and waiting for further bytes)
+        RATE on L2: Normal (raised in packets and prevents further analyzing)
     """
     pass
 
 class BadPacketException(Exception):
     """
         Raised when bad packet passed to one of read() functions
+        RATE: Fatal
+        DESC: After broken L1 packet we losing ability to analyze byte stream
+        and cannot find next packets' begin.
     """
     pass
 
 class DecoderException(Exception):
     """
         Raised when error occured in Night.destroy (Decoder)
+        RATE: Normal
+        DESC: After broken L2 packet commonly we can proceed with further packets analyzing
+        but if it was vital for protocol state changing it may prevent further 
+        comminications
     """
     pass
```

## cubelib/p.py

```diff
@@ -1,15 +1,14 @@
 """
 cubelib.p
 ===========================================================
 Module that contains the abstractions for protocol packets.
 """
 
 from dataclasses import dataclass
-from inspect import signature
 from types import ModuleType
 from typing import Union
 import zlib
 
 from cubelib.types import VarInt, SafeBuff, Optional
 from cubelib.enums import state, bound
 from cubelib.errors import BadPacketException, BufferExhaustedException, DecoderException
@@ -169,16 +168,16 @@
             try:
                 if threshold >= 0:
                     packet, tail = Packet._read_compressed(buff, bound, threshold)
                 else:
                     packet, tail = Packet._read_plain(buff, bound)
                 packets.append(packet)
                 buff = tail
-                continue            
-            except BufferExhaustedException:                
+                continue
+            except BufferExhaustedException:
                 return buff
         return buff
 
 def rrPacketsStream(buff: bytes, threshold: int, bound: bound, state: state, protocol: ModuleType, packets: list):
     """
     Read Resolve Packets Stream
 
@@ -235,30 +234,33 @@
             if isinstance(TYPE, Optional):
                 if not TYPE.is_legit(getattr(self, TYPE.field_name)):
                     continue
                 TYPE = TYPE.type
             try:
                 val = TYPE.destroy(buff)
             except Exception as e:  # NOQA
-                raise DecoderException from e
+                edesc = f"\nWhile decoding {cls}, we\n"
+                edesc += f"Failed to destroy type: {TYPE}\n"
+                edesc += f"With exception: {e}\n"
+                raise DecoderException(cls) from e
 
             size = len(val) if isinstance(val, str) else val
             if hasattr(TYPE, 'max'):
                 if size > TYPE.max:
                     raise DecoderException(f'Packet field [{name}] larger than maximum! {size} > {TYPE.max}')
 
             if hasattr(TYPE, 'min'):
                 if size < TYPE.min:
                     raise DecoderException(f'Packet field [{name}] thinker than minimum! {size} < {TYPE.max}')
 
             setattr(self, name, val)
 
-        try:
+        try:  # fixit
             unex = buff.read(1) + buff.read()
-            raise DecoderException(f"Packet [{cls.__name__}] fields over, but packet's buffer not empty yet! Unexpected data len: {len(unex)} Data: {unex}")
+            raise DecoderException(f"Packet [{cls.__name__}] fields over, but packet's buffer not empty yet! Unexpected data len: {len(unex)} Data: {unex}\nBroken Packet: {self}")
         except BufferExhaustedException:
             pass
 
         return self
 
     def _build_into_packet(self) -> Packet:
         """
@@ -270,16 +272,16 @@
         if an:
             for name in an:
                 try:
                     if isinstance(an[name], Optional):
                         if not hasattr(self, name):
                             break
 
-                        if getattr(self, an[name].field_name) != an[name].excepted_val:
-                            print(("We resolved your optional field and his tweaker is shutted down. "
+                        if not an[name].is_legit(getattr(self, an[name].field_name)):
+                            print(("We resolved your optional field and his tweaker is shutted down."
                                    "I'll hope you know what you're doin'"))
 
                     payload += an[name].build(getattr(self, name))
                 except AttributeError:
                     raise Exception(f'Failed to get {name}. Empty?')
 
         return Packet(self._id(), payload, self._bound(), False)
@@ -290,24 +292,24 @@
         return self._build_into_packet().build(cmp_threshold)
 
     def __repr__(self) -> str:
         """Show data in abstract class fields like dataclass."""
 
         full_name = str(self.__class__).split("'")[1].split(".")
 
-        def typo(x): return f"'{x}'" if type(x) is str else x  # NOQA: E704
+        def typo(x): return f"'{x}'" if isinstance(x, str) else x  # NOQA: E704
 
         out = f'{full_name[-2]}.{full_name[-1]}('
 
         try:
             an = self.__annotations__
         except AttributeError:
             return out + ')'
 
-        out += ', '.join([f'{a}={typo(getattr(self, a) if hasattr(self, a) else "UNSET BO" if not an[a].is_legit(getattr(self, an[a].field_name)) else "UNSET!?")}' for a in an])
+        out += ', '.join([f'{a}={typo(getattr(self, a) if hasattr(self, a) else "unnecessary" if not an[a].is_legit(getattr(self, an[a].field_name)) else "UNSET!?")}' for a in an])
 
         return out + ')'
 
     def __init__(self, *args):
         """Fill abstract class with given in args values."""
 
         if not hasattr(self, '__annotations__'):
@@ -318,25 +320,35 @@
                 if isinstance(an[a], Optional):
                     return True
             return False
 
         an = self.__annotations__
 
         if len(an) != len(args) and not has_optional(an) or len(args) == 0:
-            v = f'{self.__class__.__name__}({", ".join([f"{a}: {an[a].__name__ if isinstance(an[a], type) else an[a].__class__.__name__}" for a in an])})'
-            raise ValueError(f'{v} requires {len(an)} arguments but you provided only {len(args)}!')
+            raise ValueError(f'{self._sig()} requires {len(an)} arguments but you provided only {len(args)}!')
 
         for i, a in enumerate(an):
             if isinstance(an[a], Optional):
-                if not an[a].is_legit(getattr(self, an[a].field_name)):                    
-                    print(f"Annotations are over but arguments are not. Optionals mismatch?") if len(args) != i else None
+                if not an[a].is_legit(getattr(self, an[a].field_name)):
+                    if len(args) != i:
+                        # raise ValueError(f"{self._sig()}'s annotations are over but arguments are not. Optionals mismatch?")
+                        print(f"{self._sig()}'s annotations are over but arguments are not. Optionals mismatch?")
                     return
+
+            if len(args) - 1 < i:
+                raise ValueError(f'{self._sig()} with this Optionals configuration requires {i}+ arguments but you provided only {len(args)}!')
+
             setattr(self, a, args[i])
 
     @classmethod
+    def _sig(class_) -> str:
+        an = class_.__annotations__
+        return f'{class_.__name__}({", ".join([f"{a}: {an[a].__name__ if isinstance(an[a], type) else an[a].__class__.__name__}" for a in an])})'
+
+    @classmethod
     def _id(class_) -> int:
         """Find abstract packet's ID in protocol class map."""
 
         from cubelib import proto
         w = str(class_).split("'")[1].split('.')[:-1][2:]
         map = getattr(getattr(getattr(proto, w[0]), w[1]), w[2]).inv_map
         return map[class_]
```

## cubelib/types.py

```diff
@@ -5,16 +5,19 @@
 """
 
 from io import BytesIO
 from enum import Enum
 from struct import pack, unpack
 
 from cubelib.errors import BufferExhaustedException
+from cubelib.enums import state
 
 from typing import Tuple
+from uuid import UUID as UUIDD
+from nbt import nbt  # NBT
 
 class SafeBuff(BytesIO):
     """
     This class make BytesIO object safe for reading.
     It re-defines read() method and add returned bytes length comparison with requested,
     and raises BufferExhaustedException if it not equal.
     """
@@ -25,14 +28,217 @@
             return super().read()
 
         r = super().read(a[0])
         if len(r) != a[0]:
             raise BufferExhaustedException(f'Buffer returned {len(r)} instead of required {a[0]}')
         return r
 
+    def close(self) -> None:
+        """Don't close your eyes"""
+        return None
+
+class NBT(nbt.NBTFile):
+
+    TAGS_TO_STR = {
+        nbt.TAG_Short: 'short',
+        nbt.TAG_Int: 'int',
+        nbt.TAG_Long: 'long',
+        nbt.TAG_Byte: 'byte',
+        nbt.TAG_Float: 'float',
+        nbt.TAG_Double: 'double',
+        nbt.TAG_Byte_Array: 'bytearray',
+        # TAG_Int_Array: 'bytearray',
+        nbt.TAG_Compound: 'dict',
+        nbt.TAG_String: 'str',
+        nbt.TAG_List: 'list'
+    }
+    STRS_TO_TAG = {v: k for k, v in TAGS_TO_STR.items()}
+    STRS_TO_STRS = {i.__name__: k for i, k in TAGS_TO_STR.items()}
+
+    @staticmethod
+    def __nbt_list_to_list(tag_list: nbt.TAG_List) -> list:
+        output = []
+
+        for tag in tag_list.tags:
+            if isinstance(tag, nbt.TAG_List):
+                type_ = NBT.STRS_TO_STRS[tag.tag_info().split(': [')[1][:-4].split(' ')[1]]
+                value = (type_, NBT.__nbt_list_to_list(tag))
+
+            elif isinstance(tag, nbt.TAG_Compound):
+                value = NBT.__nbt_compound_to_dict(tag)
+
+            elif isinstance(tag, nbt.TAG_String):
+                value = tag.value
+
+            else:
+                value = (NBT.TAGS_TO_STR[tag.__class__], tag.value)
+
+            output.append(value)
+
+        #print(f"LIST->LIST {tag_list.name} -> {output}")
+        return output
+
+    @staticmethod
+    def __nbt_compound_to_dict(tag_compound: nbt.TAG_Compound) -> dict:
+        output = {}
+
+        for tag in tag_compound.tags:
+            if isinstance(tag, nbt.TAG_List):
+                type_ = NBT.STRS_TO_STRS[tag.tag_info().split(': [')[1][:-4].split(' ')[1]]
+                value = (type_, NBT.__nbt_list_to_list(tag))
+
+            elif isinstance(tag, nbt.TAG_Compound):
+                value = NBT.__nbt_compound_to_dict(tag)
+
+            elif isinstance(tag, nbt.TAG_String):
+                value = tag.value
+
+            else:
+                value = (NBT.TAGS_TO_STR[tag.__class__], tag.value)
+
+            output[tag.name] = value
+
+        #print(f"COMP->DICT {tag_compound.name} -> {output}")
+        return output
+
+    def to_dict(self: nbt.NBTFile) -> dict:
+        return {self.name: NBT.__nbt_compound_to_dict(self)}
+
+    @staticmethod
+    def from_dict(data: dict) -> nbt.NBTFile:
+        compound = list(data)[0]
+
+        instance = NBT()
+        instance.name = compound
+
+        data = data[compound]
+
+        for key, value in data.items():
+            if isinstance(value, dict):
+                instance.tags.append(NBT.__dict_to_nbt_compound(value, name=key))
+
+            elif isinstance(value, tuple):
+                if not isinstance(value[1], list):
+                    vinstance = NBT.STRS_TO_TAG[value[0]](name=key)
+                    vinstance.value = value[1]
+                else:
+                    vinstance = NBT.__list_to_nbt_list(*value, name=key)
+                instance.tags.append(vinstance)
+
+            elif isinstance(value, str):
+                instance.tags.append(nbt.TAG_String(value, name=key))
+
+        #print(f"DICT->NBTF '{compound}' -> {instance}")
+        return instance
+
+    @staticmethod
+    def __dict_to_nbt_compound(data: dict, name='') -> nbt.TAG_Compound:
+        instance = nbt.TAG_Compound(name=name)
+
+        for key, value in data.items():
+            if isinstance(value, dict):
+                instance.tags.append(NBT.__dict_to_nbt_compound(value, name=key))
+
+            elif isinstance(value, tuple):
+                if not isinstance(value[1], list):
+                    vinstance = NBT.STRS_TO_TAG[value[0]](name=key)
+                    vinstance.value = value[1]
+                else:
+                    vinstance = NBT.__list_to_nbt_list(*value, name=key)
+                instance.tags.append(vinstance)
+
+            elif isinstance(value, str):
+                instance.tags.append(nbt.TAG_String(value, name=key))
+
+        #print(f"DICT->COMP {name} -> {instance}")
+        return instance
+
+    @staticmethod
+    def __list_to_nbt_list(type_: str, data: list, name='') -> nbt.TAG_List:
+        instance = nbt.TAG_List(NBT.STRS_TO_TAG[type_], name=name)
+
+        for key in data:
+            if isinstance(key, dict):
+                instance.append(NBT.__dict_to_nbt_compound(key))
+
+            elif isinstance(key, tuple):
+                if not isinstance(key[1], list):
+                    vinstance = NBT.STRS_TO_TAG[key[0]]()
+                    vinstance.value = key[1]
+                else:
+                    vinstance = NBT.__list_to_nbt_list(*key)
+                instance.tags.append(vinstance)
+
+            elif isinstance(key, str):
+                instance.tags.append(nbt.TAG_String(key))
+
+            else:
+                vinstance = NBT.STRS_TO_TAG[type_]()
+                vinstance.value = key
+                instance.tags.append(vinstance)
+
+        #print(f"LIST->LIST {type_} -> {instance}")
+        return instance
+
+    def __eq__(self, other):
+        if not isinstance(other, NBT):
+            return False
+
+        return self.to_dict() == other.to_dict()
+
+    @staticmethod
+    def destroy(buff: SafeBuff) -> nbt.NBTFile:
+        return NBT(buffer=buff)
+
+    def build(self) -> bytes:
+        buff = SafeBuff()
+        self.write_file(buffer=buff)
+        return buff.getvalue()
+
+    def __str__(self) -> str:
+        return self.__repr__()
+
+    def __repr__(self) -> str:
+
+        def unwrap_nbt_list(tag):
+            out = []
+            for tag in tag.tags:
+                if isinstance(tag, nbt.TAG_List):
+                    val = unwrap_nbt_list(tag)
+
+                elif isinstance(tag, nbt.TAG_Compound):
+                    val = unwrap_nbt_dict(tag)
+                else:
+                    val = tag.value
+
+                out.append(val)
+
+            return out
+
+        def unwrap_nbt_dict(tag):
+            out = {}
+
+            for tag in tag.tags:
+                if isinstance(tag, nbt.TAG_List):
+                    val = unwrap_nbt_list(tag)
+
+                elif isinstance(tag, nbt.TAG_Compound):
+                    val = unwrap_nbt_dict(tag)
+
+                else:
+                    val = tag.value
+
+                out[tag.name] = val
+
+            return out
+        # print(f"NBTEntry['{self.name}']({unwrap_nbt_dict(self)})")
+        # print(f"NBTEntry['{self.name}']({NBT.__nbt_compound_to_dict(self)})")
+        return f"NBTEntry['{self.name}']({unwrap_nbt_dict(self)})"  # not-annotated
+        # return f"NBTEntry['{self.name}']({NBT.__nbt_compound_to_dict(self)})"
+
 class Optional:
     """
     Special type, container for basic types that make them optional,
     decoder must read optional type only if other field, provided in field_name equals (or not quals if inv)
     to excepted_val.
     """
 
@@ -119,183 +325,143 @@
             total += pack('B', (0x80 | bits))
         bits = val & 0x7F
         total += pack('B', bits)
         return total
 
 class MCEnum(Enum):
 
+    """
+        Most enums stored here (in types.py) and alliased from concrete packets that implements them.
+        Why stored here? Idk but we need to separate it from packet for cross-version inheritance.
+    """
+
     IntegerType: type
 
     @classmethod
     def destroy(class_, buff: SafeBuff):
         return class_(class_.__annotations__['IntegerType'].destroy(buff))
 
     def build(self) -> bytes:
         return self.__annotations__['IntegerType'].build(self.value)
 
+    def __str__(self) -> str:
+        return self.name
+
 class FiniteLengthArray:
 
-    def __class_getitem__(class_, val):
+    def __init__(self, itype: type):
+        self.ITYPE = itype
 
-        obj = class_()
-        obj.TYPE = val
-        return obj
+    def __getitem__(self, val):
+
+        self.TYPE = val
+        return self
 
     def destroy(self, buff: SafeBuff) -> list:
 
-        count = VarInt.destroy(buff)
+        count = self.ITYPE.destroy(buff)
         out = []
         for x in range(0, count):
             try:
                 out.append(self.TYPE.destroy(buff))
             except BufferExhaustedException as e:
                 raise RuntimeError(f"Buffer exhauseted on {x}/{count} iteration of decoding array of {self.TYPE}") from e
         return out
 
     def build(self, val: list) -> bytes:
 
-        out = VarInt.build(len(val))
+        out = self.ITYPE.build(len(val))
         for i in val:
             out += self.TYPE.build(i)
         return out
 
 class UnsignedShort:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
         return unpack('!H', buff.read(2))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
         return pack('!H', val)
 
-class String:
-
-    @staticmethod
-    def build(val: str) -> bytes:
+class NextState:
 
-        o = b""
-        o += VarInt.build(len(val))
-        o += val.encode()
-        return o
+    Status = state.Status  # deprecated. removal release: 1.1.x. use cubelib.state instead!
+    Login = state.Login  # deprecated. removal release: 1.1.x. use cubelib.state instead!
 
     @staticmethod
-    def destroy(buff: SafeBuff) -> str:
-
-        l = VarInt.destroy(buff)
-        return buff.read(l).decode()
-
-    def __class_getitem__(class_, val):
-
-        obj = class_()
-
-        # Type[int] set max length\max value
-        if isinstance(val, int):
-            obj.max = val
-
-        # Type[[int]] set excepted length\value
-        elif isinstance(val, list) and len(val) == 1:
-
-            obj.min = val[0]
-            obj.max = val[0]
+    def destroy(buff: SafeBuff):
+        return state(int.from_bytes(buff.read(1), 'little'))
 
-        # Type[int, int] set range of excepted values\len
-        elif isinstance(val, tuple) and len(val) == 2:
+    @staticmethod
+    def build(NextState: state) -> bytes:
+        if NextState not in [state.Status, state.Login]:
+            raise ValueError(f"NextState can be only Status or Login!")
+        return bytes([NextState.value])
 
-            obj.min = val[0]
-            obj.max = val[1]
+class Bool:
 
-        else:
-            raise Exception('какой далбаеб писал анатацию?!?!')
+    @staticmethod
+    def destroy(buff: SafeBuff) -> bool:
+        return unpack('!?', buff.read(1))[0]
 
-        return obj
+    @staticmethod
+    def build(val: bool) -> bytes:
+        return pack('!?', val)
 
-class Long:
+class Byte:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
-        return unpack('!q', buff.read(8))[0]
+        return unpack('!b', buff.read(1))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
-        return pack('!q', val)
-
-class NextState(Enum):
-
-    Status = 1
-    Login = 2
-
-    @staticmethod
-    def destroy(buff: SafeBuff):
-        return NextState(int.from_bytes(buff.read(1), 'little'))
-
-    def build(self) -> bytes:
-        return bytes([self.value])
+        return pack('!b', val)
 
 class UnsignedByte:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
         return unpack('!B', buff.read(1))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
         return pack('!B', val)
 
-class Byte:
+class Short:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
-        return unpack('!b', buff.read(1))[0]
+        return unpack('!h', buff.read(2))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
-        return pack('!b', val)
-
-class Bool:
-
-    @staticmethod
-    def destroy(buff: SafeBuff) -> bool:
-        return unpack('!?', buff.read(1))[0]
-
-    @staticmethod
-    def build(val: bool) -> bytes:
-        return pack('!?', val)
+        return pack('!h', val)
 
 class Int:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
         return unpack('!i', buff.read(4))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
         return pack('!i', val)
 
-class ByteArray:
-
-    @staticmethod
-    def destroy(buff: SafeBuff) -> bytes:
-        return buff.read()
-
-    @staticmethod
-    def build(val: bytes) -> bytes:
-        return val
-
-class Position:
+class Long:
 
     @staticmethod
-    def destroy(buff: SafeBuff) -> Tuple[int, int, int]:
-        buff.read(8)
-        return (-1, -1, -1)
+    def destroy(buff: SafeBuff) -> int:
+        return unpack('!q', buff.read(8))[0]
 
     @staticmethod
-    def build(val: tuple) -> bytes:
-
-        return b"\x41"*8
+    def build(val: int) -> bytes:
+        return pack('!q', val)
 
 class Float:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
         return unpack('!f', buff.read(4))[0]
 
@@ -309,87 +475,296 @@
     def destroy(buff: SafeBuff) -> int:
         return unpack('!d', buff.read(8))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
         return pack('!d', val)
 
-class Short:
-    
+class String:
+
     @staticmethod
-    def destroy(buff: SafeBuff) -> int:
-        return unpack('!h', buff.read(2))[0]
+    def build(val: str) -> bytes:
+
+        o = b""
+        i = val.encode()
+        o += VarInt.build(len(i))
+        o += i
+        return o
 
     @staticmethod
-    def build(val: int) -> bytes:
-        return pack('!h', val)
+    def destroy(buff: SafeBuff) -> str:
+
+        l = VarInt.destroy(buff)
+        return buff.read(l).decode()
+
+    def __class_getitem__(class_, val):
+
+        obj = class_()
+
+        # Type[int] set max length\max value
+        if isinstance(val, int):
+            obj.max = val
+
+        # Type[[int]] set excepted length\value
+        elif isinstance(val, list) and len(val) == 1:
+
+            obj.min = val[0]
+            obj.max = val[0]
+
+        # Type[int, int] set range of excepted values\len
+        elif isinstance(val, tuple) and len(val) == 2:
+
+            obj.min = val[0]
+            obj.max = val[1]
+
+        else:
+            raise Exception('какой далбаеб писал анатацию?!?!')
+
+        return obj
+
+class ByteArray(bytes):
+
+    @staticmethod
+    def destroy(buff: SafeBuff):
+        return ByteArray(buff.read())
+
+    @staticmethod
+    def build(val) -> bytes:
+        return val
+
+    def __str__(self) -> str:
+        return f"ByteArray[{len(self)}]"
+
+class Position:
+
+    def destroy(buff: SafeBuff) -> Tuple[int, int, int]:
+        """Ver-dependent type"""
+        ...
+
+    def build(val: tuple) -> bytes:
+        """Ver-dependent type"""
+        ...
 
 class Angle:
 
     @staticmethod
     def destroy(buff: SafeBuff) -> int:
         return unpack('!B', buff.read(1))[0]
 
     @staticmethod
     def build(val: int) -> bytes:
         return pack('!B', val)
 
-class Slot(ByteArray):
-    pass
-
 class FiniteLengthByteArray(ByteArray):
 
     @staticmethod
-    def destroy(buff: SafeBuff) -> bytes:        
+    def destroy(buff: SafeBuff) -> bytes:
         return buff.read(VarInt.destroy(buff))
-    
+
     @staticmethod
     def build(val: bytes) -> bytes:
         out = VarInt.build(len(val))
         out += val
         return out
 
 class UUID:
 
     @staticmethod
-    def destroy(buff: SafeBuff) -> bytes:
-        return buff.read(16)
-    
+    def destroy(buff: SafeBuff) -> UUIDD:
+        return UUIDD(bytes=buff.read(16))
+
     @staticmethod
-    def build(val: bytes) -> bytes:
-        return val
+    def build(val: UUIDD) -> bytes:
+        return val.bytes
 
-class PlayerDiggingStatusEnum(MCEnum):
 
-    IntegerType:  Byte
+class PlayerListItemData:
+
+    class Action(Enum):
+        AddPlayer = 0
+        UpdateGamemode = 1
+        UpdateLatency = 2
+        UpdateDisplayName = 3
+        RemovePlayer = 4
+
+    @staticmethod
+    def destroy(buff: SafeBuff) -> dict:
+        action = VarInt.destroy(buff)
+        num_of_players = VarInt.destroy(buff)
+
+        players = []
+        for _ in range(num_of_players):
+            uuid = UUID.destroy(buff)
+            if action == 0:
+                name = String.destroy(buff)
+                properties_len = VarInt.destroy(buff)
+                properties = []
+                for i in range(properties_len):
+                    pname = String.destroy(buff)
+                    value = String.destroy(buff)
+                    signed = Bool.destroy(buff)
+                    signature = String.destroy(buff) if signed else None
+
+                    property_ = {
+                        "name": pname,
+                        "value": value,
+                        "signed": signed,
+                        "signature": signature
+                    }
+                    properties.append(property_)
+
+                gamemode = VarInt.destroy(buff)
+                ping = VarInt.destroy(buff)
+                has_display_name = Bool.destroy(buff)
+                display_name = String.destroy(buff) if has_display_name else None
+                players.append({
+                    "uuid": uuid,
+                    "name": name,
+                    "properties": properties,
+                    "gamemode": gamemode,
+                    "ping": ping,
+                    "display_name": display_name
+                })
+
+            elif action == 1:
+                players.append({"uuid": uuid, "gamemode": VarInt.destroy(buff)})
+
+            elif action == 2:
+                players.append({"uuid": uuid, "ping": VarInt.destroy(buff)})
+
+            elif action == 3:
+                has_display_name = Bool.destroy(buff)
+                display_name = String.destroy(buff) if has_display_name else None
+                players.append({"uuid": uuid, "display_name": display_name})
+
+            elif action == 4:
+                players.append({"uuid": uuid})
+
+        return {"action": PlayerListItemData.Action(action), "players": players}
+
+    @staticmethod
+    def build(val: dict):
+        action = val["action"]
+        out = VarInt.build(action.value)
+        out += VarInt.build(len(val["players"]))
+
+        for player in val["players"]:
+            out += UUID.build(player["uuid"])
+            if action == PlayerListItemData.Action.AddPlayer:
+                out += String.build(player["name"])
+                out += VarInt.build(len(player["properties"]))
+
+                for property_ in player["properties"]:
+                    out += String.build(property_["name"])
+                    out += String.build(property_["value"])
+                    out += Bool.build("signature" in property_)
+                    if "signature" in property_:
+                        out += String.build(property_["signature"])
+
+                out += VarInt.build(player["gamemode"])
+                out += VarInt.build(player["ping"])
+                out += Bool.build(player["display_name"])
+                if player["display_name"]:
+                    out += String.build(player["display_name"])
+
+            elif action == PlayerListItemData.Action.UpdateGamemode:
+                out += VarInt.build(player["gamemode"])
+
+            elif action == PlayerListItemData.Action.UpdateLatency:
+                out += VarInt.build(player["ping"])
+
+            elif action == PlayerListItemData.Action.UpdateDisplayName:
+                out += Bool.build("display_name" in player)
+                if "display_name" in player:
+                    out += String.build(player["display_name"])
 
-    StartedDigging = 0
-    CancelledDigging = 1
-    FinishedDigging = 2
-    DropItemStack = 3
-    DropItem = 4
-    ShootArrow_FinishEating = 5
+            elif action == PlayerListItemData.Action.RemovePlayer:
+                pass
 
-class FaceEnum(MCEnum):
+        return out
 
-    IntegerType: Byte
+class Property:
 
-    YNEG = 0
-    YPOS = 1
-    ZNEG = 2
-    ZPOS = 3
-    XNEG = 4
-    XPOS = 5
+    @staticmethod
+    def destroy(buff: SafeBuff):
+        key = String.destroy(buff)
+        value = Double.destroy(buff)
+        num_of_modifiers = VarInt.destroy(buff)
+        modifiers = []
+        for _ in range(num_of_modifiers):
+            modifiers.append({
+                "uuid": UUID.destroy(buff),
+                "amount": Double.destroy(buff),
+                "operation": Byte.destroy(buff)
+            })
+        return {"key": key, "value": value, "modifiers": modifiers}
+
+    @staticmethod
+    def build(val: dict):
+        # undone
+        print(val)
+        return b"\x41" * 5
+
+class BlockID:
+    # ver-dependent
+    ...
+
+class Slot:
+    # ver-dependent
+    ...
+
+class Metadata:
+    # ver-dependent
+    ...
+
+class ChunkMeta:
+
+    @staticmethod
+    def destroy(buff: SafeBuff) -> (int, int, int):
+        ChunkX = Int.destroy(buff)
+        ChunkZ = Int.destroy(buff)
+        PrimaryBitMask = UnsignedShort.destroy(buff)
+        return ChunkX, ChunkZ, PrimaryBitMask
+
+    @staticmethod
+    def build(val: tuple) -> bytes:
+        out = Int.build(val[0])
+        out += Int.build(val[1])
+        out = UnsignedShort.build(val[2])
+        return out
+
+class StatisticsElement:
 
-    SPEC = 255
+    @staticmethod
+    def destroy(buff: SafeBuff) -> dict:
+        name = String.destroy(buff)
+        value = VarInt.destroy(buff)
+        return {"name": name, "value": value}
 
-class EntityActionActionIDEnum(MCEnum):
+    @staticmethod
+    def build(val: dict) -> bytes:
+        out = String.build(val["name"])
+        out += VarInt.build(val["value"])
+        return out
 
-    IntegerType: VarInt
+class BitMask:
+        
+    Active: list
+    
+    @classmethod
+    def destroy(cls, buff: SafeBuff):
+        integer = UnsignedByte.destroy(buff)
+        instance = cls()
+        instance.Active = []
+
+        for k, v in cls.__dict__.items():
+            if not k.startswith("__"):
+                if integer & v == v:
+                    instance.Active.append(k)
+
+        return instance
+    
+    def build(cls, val: int):
+        return UnsignedByte.build(val)
 
-    StartSneaking = 0
-    StopSneaking = 1
-    LeaveBed = 2
-    StartSprinting = 3
-    StopSprinting = 4
-    JumpWithHorse = 5
-    OpenRiddenHorseInventory = 6
+    def __str__(self):        
+        return f"BitMask({'|'.join(self.Active)})"
```

## cubelib/proto/v47/ClientBound.py

```diff
@@ -1,22 +1,26 @@
-from ...types import *
-from ...p import Night
+from .types import *
+from cubelib.p import Night
 from cubelib.proto.version_independent.ClientBound import ClassicLogin
+from .enums import *
+from cubelib.mcenums import *
 
 
 class Login(ClassicLogin):
     pass
 
 class Play:
 
     class JoinGame(Night):
 
+        Dimension = JoinGameDimensionEnum
+
         EntityID: Int
         Gamemode: UnsignedByte
-        Dimension: Byte
+        Dimension: JoinGameDimensionEnum
         Difficulty: UnsignedByte
         MaxPlayers: UnsignedByte
         LevelType: String
         ReducedDebugInfo: Bool
 
     class PluginMessage(Night):
 
@@ -48,16 +52,18 @@
 
         Flags: Byte
         FlyingSpeed: Float
         FOVModifier: Float
 
     class ChatMessage(Night):
 
+        Position = ChatMessagePositionEnum
+
         Json_Data: String
-        Position: Byte
+        Position: ChatMessagePositionEnum
 
     class KeepAlive(Night):
 
         KeepAliveID: VarInt
 
     class PlayerPositionAndLook(Night):
 
@@ -75,17 +81,16 @@
     class TimeUpdate(Night):
 
         WorldAge: Long
         TimeOfDay: Long
 
     class WindowItems(Night):
 
-        WindowID: UnsignedByte
-        Count: Short
-        SlotData: ByteArray
+        WindowID: UnsignedByte        
+        SlotData: FiniteLengthArray(Short)[Slot]
 
     class EntityRelativeMove(Night):
 
         EntityID: VarInt
         DeltaX: Byte
         DeltaY: Byte
         DeltaZ: Byte
@@ -150,49 +155,49 @@
         PlayerUUID: UUID
         X: Int
         Y: Int
         Z: Int
         Yaw: Angle
         Pitch: Angle
         CurrentItem: Short
-        Metatdata: ByteArray # ?metadata
+        Metadata: Metadata # ?metadata
     
     class CollectItem(Night):
 
         CollectedEntityID: VarInt
         CollectorEntityID: VarInt
 
     class SpawnObject(Night):
 
         EntityID: VarInt
-        Type: Byte
+        Type: Object
         X: Int
         Y: Int
         Z: Int
         Pitch: Angle
         Yaw: Angle
         Data: Int
         VelocityX: Optional('Data', 0, equals=False)[Short]
         VelocityY: Optional('Data', 0, equals=False)[Short]
         VelocityZ: Optional('Data', 0, equals=False)[Short]
 
     class SpawnMob(Night):
 
         EntityID: VarInt
-        Type: UnsignedByte
+        Type: Mob
         X: Int
         Y: Int
         Z: Int
         Yaw: Angle
         Pitch: Angle
         HeadPitch: Angle
         VelocityX: Short
         VelocityY: Short
         VelocityZ: Short
-        Metatdata: ByteArray # ?metadata
+        Metadata: Metadata # ?metadata
     
     class SpawnPainting(Night):
 
         EntityID: VarInt
         Title: String[13]
         Location: Position
         Direction: UnsignedByte
@@ -203,15 +208,15 @@
         X: Int
         Y: Int
         Z: Int
         Count: Short
 
     class DestroyEntities(Night):
 
-        EntityIDs: FiniteLengthArray[VarInt]
+        EntityIDs: FiniteLengthArray(VarInt)[VarInt]
 
     class Entity(Night):
 
         EntityID: VarInt
     
     class EntityTeleport(Night):
 
@@ -228,15 +233,15 @@
         EntityID: Int
         VehicleID: Int
         Leash: Bool
     
     class EntityMetadata(Night):
 
         EntityID: VarInt
-        Metatdata: ByteArray
+        Metadata: Metadata
     
     class EntityEffect(Night):
 
         EntityID: VarInt
         EffectID: Byte
         Amplifier: Byte
         Duration: VarInt
@@ -252,15 +257,15 @@
         ExperienceBar: Float
         Level: VarInt
         TotalExperience: VarInt
 
     class EntityProperties(Night):
 
         EntityID: VarInt
-        Data: ByteArray
+        Properties: FiniteLengthArray(Int)[Property]
     
     class ChunkData(Night):
 
         ChunkX: Int
         ChunkZ: Int
         GroundUpCont: Bool
         PrimaryBitMask: UnsignedShort
@@ -271,15 +276,15 @@
         ChunkX: Int
         ChunkZ: Int
         Data: ByteArray
 
     class BlockChange(Night):
 
         Location: Position
-        BlockID: VarInt
+        BlockID: BlockID
 
     class BlockAction(Night):
 
         Location: Position
         Byte1: UnsignedByte
         Byte2: UnsignedByte
         BlockType: VarInt
@@ -289,14 +294,15 @@
         EntityID: VarInt
         Location: Position
         DestroyStage: Byte
 
     class MapChunkBulk(Night):
 
         SkyLightSent: Bool
+        ChunkMeta: FiniteLengthArray(VarInt)[ChunkMeta]
         Data: ByteArray
 
     class Explosion(Night):
 
         X: Float
         Y: Float
         Z: Float
@@ -331,15 +337,17 @@
         OffsetZ: Float
         ParticleData: Float
         ParticleCount: Int
         Data: ByteArray
 
     class ChangeGameState(Night):
 
-        Reason: UnsignedByte
+        Reason = ChangeGameStateReasonEnum
+
+        Reason: Reason
         Value: Float
     
     class SpawnGlobalEntity(Night):
 
         EntityID: VarInt
         Type: Byte
         X: Int
@@ -373,60 +381,64 @@
         WindowID: Byte
         ActionNumber: Short
         Accepted: Bool
     
     class UpdateSign(Night):
 
         Location: Position
-        Lines: ByteArray
+        Line1: String
+        Line2: String
+        Line3: String
+        Line4: String
     
     class Map(Night):
 
         MapID: VarInt
         Scale: Byte
         Data: ByteArray
 
     class UpdateBlockEntity(Night):
 
         Location: Position
-        Action: UnsignedByte
-        Data: ByteArray
+        Action: UpdateBlockEntityActionEnum
+        NBTData: NBT
     
     class OpenSignEditor(Night):
 
         Location: Position
     
     class Statistics(Night):
 
-        Count: VarInt
-        Data: ByteArray
+        Statistics: FiniteLengthArray(VarInt)[StatisticsElement]
 
     class PlayerListItem(Night):
 
-        Action: VarInt
-        NumberOfPlayers: VarInt
-        Data: ByteArray
+        Data: PlayerListItemData
 
     class TabComplete(Night):
 
-        Matches: FiniteLengthArray[String]
+        Matches: FiniteLengthArray(VarInt)[String]
     
     class ScoreboardObjective(Night):
 
+        Mode = ScoreboardObjectiveModeEnum
+
         ObjectiveName: String
-        Mode: Byte
-        ObjectiveValue: Optional("Mode", (0, 2))[String]
-        Type: Optional("Mode", (0, 2))[String]
+        Mode: ScoreboardObjectiveModeEnum
+        ObjectiveValue: Optional("Mode", (Mode.Create, Mode.Update))[String]
+        Type: Optional("Mode", (Mode.Create, Mode.Update))[String]
 
     class UpdateScore(Night):
 
+        Action = UpdateScoreActionEnum
+
         ScoreName: String
-        Action: Byte
+        Action: UpdateScoreActionEnum
         ObjectiveName: String
-        Value: Optional("Action", 1, equals=False)[VarInt]
+        Value: Optional("Action", Action.Update)[VarInt]
     
     class DisplayScoreboard(Night):
 
         Position: Byte
         Name: String
     
     class Teams(Night):
@@ -464,15 +476,16 @@
 
     class SetCompression(Night):
 
         Threshold: VarInt #warn
     
     class PlayerListHeaderAndFooter(Night):
 
-        Data: ByteArray
+        Header: String
+        Footer: String
 
     class ResourcePackSend(Night):
         
         URL: String
         Hash: String[[40]]
 
     class UpdateEntityNBT(Night):
```

## cubelib/proto/v47/ServerBound.py

```diff
@@ -1,11 +1,11 @@
-from ...types import *
+from .types import *
 from cubelib.p import Night
-
 from cubelib.proto.version_independent.ServerBound import ClassicLogin
+from cubelib.mcenums import *
 
 
 class Login(ClassicLogin):
     pass
 
 class Play:
 
@@ -15,19 +15,21 @@
 
     class ChatMessage(Night):
 
         Message: String
 
     class UseEntity(Night):
 
+        Type = UseEntityTypeEnum            
+
         Target: VarInt
-        Type: VarInt
-        TargetX: Optional('Type', 2)[Float]
-        TargetY: Optional('Type', 2)[Float]
-        TargetZ: Optional('Type', 2)[Float]
+        Type: Type
+        TargetX: Optional('Type', UseEntityTypeEnum.InteractAt)[Float]
+        TargetY: Optional('Type', UseEntityTypeEnum.InteractAt)[Float]
+        TargetZ: Optional('Type', UseEntityTypeEnum.InteractAt)[Float]
 
     class Player(Night):
 
         OnGround: Bool
 
     class PlayerPosition(Night):
 
@@ -49,33 +51,43 @@
         Z: Double
         Yaw: Float
         Pitch: Float
         OnGround: Bool
 
     class PlayerDigging(Night):
 
+        Status = PlayerDiggingStatusEnum 
+        Face = FaceEnum
+
         Status: PlayerDiggingStatusEnum
         Location: Position
         Face: FaceEnum
 
     class PlayerBlockPlacement(Night):
 
+        Face = FaceEnum
+
         Location: Position
         Face: FaceEnum
         HeldItem: Slot
+        CrosshairX: Byte
+        CrosshairY: Byte
+        CrosshairZ: Byte
 
     class HeldItemChange(Night):
 
         Slot: Short
 
     class Animation(Night):
         pass
 
     class EntityAction(Night):
 
+        ActionID = EntityActionActionIDEnum
+
         EntityID: VarInt
         ActionID: EntityActionActionIDEnum
         ActionParam: VarInt
 
     class SteerVehicle(Night):
 
         Sideways: Float
@@ -129,19 +141,21 @@
 
         Text: String
         HasPosition: Bool
         LookedAtBlock: ByteArray
 
     class ClientSettings(Night):
 
+        ChatMode = ClientSettingsChatModeEnum
+
         Locale: String
         VievDistance: Byte
-        ChatMode: Byte
+        ChatMode: ClientSettingsChatModeEnum
         ChatColors: Bool
-        DisplayedSkinParts: UnsignedByte
+        DisplayedSkinParts: ClientSettingsSkinPartsBitmaskEnum
 
     class ClientStatus(Night):
 
         ActionID: VarInt
 
     class PluginMessage(Night):
```

## cubelib/proto/v47/__init__.py

```diff
@@ -1,3 +1,4 @@
 from . import ClientBound, ServerBound
+from .enums import *
 name = 'Minecraft Java Edition protocol version 47'
 version = 47
```

## Comparing `cubelib-1.0.5rc2.dist-info/LICENSE` & `cubelib-1.0.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cubelib-1.0.5rc2.dist-info/METADATA` & `cubelib-1.0.7.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cubelib
-Version: 1.0.5rc2
+Version: 1.0.7
 Summary: python library for building/parsing minecraft protocol packets
 Home-page: https://gitlab.com/seeklay/cubelib
 Author: seeklay
 Author-email: rudeboy@seeklay.icu
 License: GNU General Public License v3.0
 Download-URL: https://gitlab.com/seeklay/cubelib
 Platform: OS Independent
```

## Comparing `cubelib-1.0.5rc2.dist-info/RECORD` & `cubelib-1.0.7.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,25 +1,28 @@
-cubelib/__init__.py,sha256=TxwkAy3v4_F29_imOlfCz4YyNRR-VsrJbFj5ahIlcVM,218
+cubelib/__init__.py,sha256=PyKUQbmI1I_9ao0twvNVzP78WR4RtuIENuFrJk19Wsc,278
 cubelib/enums.py,sha256=gUktCNejMX9yOPO5KsQbEDbF4Eb6SQaHz9U0JkKXnVU,161
-cubelib/errors.py,sha256=By8ENG_sQCfZ-qfLQK_7PpNW6HAGEndEAGN65m2c7AU,376
+cubelib/errors.py,sha256=3Bm_niMjKl6C4wl8NYF5K_-8qAviPrrjhy3u4RiGP6w,892
 cubelib/iautil.py,sha256=SdQwcfsYuSG4JFMR1NrfcVHDLZQF4WYmG1FpfI3ysbw,611
+cubelib/mcenums.py,sha256=9VwNx6t9pdyTuSz0_qnYxKwf6MGsb9PFouyrF0FSOPc,2032
 cubelib/mcsr.py,sha256=ngpGYaGHnSpwdiJQBVkUq-jOlxhNIKHX2dGqsDy2aOE,16297
-cubelib/p.py,sha256=SsIKFkxclq5iX5c9bQu-4Fx0LSxYIdUTuiteDRNmXRQ,11621
-cubelib/types.py,sha256=ou9fOTPHuvaqHD7pjlyi43T82FR6-PgUC8N-Vuzh5rU,8973
+cubelib/p.py,sha256=qont7FOrE7_Kt4NpRODu95QOnnVbWvblAU8Nfj3vbZk,12173
+cubelib/types.py,sha256=iAB4MpKSaEIhIs7SOEz37WxDg-WNnrwFJZ0mdFx7mEU,21651
 cubelib/aio/__init__.py,sha256=YAfWChoNDFjVpw_HXAHah25OgsSq7Z_EEaK4DqcPHTQ,50
 cubelib/aio/aio.py,sha256=TuhHio_VjiqR67_-5a4H5hJ3iy237DT_nZJn2GL3R5Q,2656
 cubelib/proto/__init__.py,sha256=qKNIsPolW3wZrl3QyTFxRy7zLh5eA6ByzX10LCkYZLM,57
 cubelib/proto/v340/ClientBound.py,sha256=YLFBhVRkTyYgGGT9XO4LbZ7nv5Ov_9d7XvT0GD1CWfc,203
 cubelib/proto/v340/ServerBound.py,sha256=lV6cM7cl9SVSFa8spEoq8fYuOdI7oBrHW6e8qEYWxFs,299
 cubelib/proto/v340/__init__.py,sha256=IRbmcF-TDB6SlwJLZO6YcTdFoVumed7qEvzkWo11q-A,105
-cubelib/proto/v47/ClientBound.py,sha256=qDRvJ2JZ_aUoXeEIBuuVidJEULCRZXM5aENbtQPUzHQ,11284
-cubelib/proto/v47/ServerBound.py,sha256=PJd8oHs028ueEOic092WO3oC74n5qG0pseMRK0FdWU8,3695
-cubelib/proto/v47/__init__.py,sha256=7KQDr3_yvY1EU7oGh_gkqzRoQNs91NISnJL2A681fgc,103
+cubelib/proto/v47/ClientBound.py,sha256=Al4Wsh1d7Y0XQMgWl7S33zaNYht2EPMHUYn2ovjAC-A,11828
+cubelib/proto/v47/ServerBound.py,sha256=FTYKq4OXD7TeXDNGRo1guaN0TvABIEvpcPkGIHuya5k,4150
+cubelib/proto/v47/__init__.py,sha256=2yCXeyyhJ6YdVXgDKvMxKanVxvKmDSGlka1gPYT31fI,124
+cubelib/proto/v47/enums.py,sha256=PoMLnkcnGaKwUk0v2L7H6Ni8N_BbVYjQaDexGCHJF-I,12408
+cubelib/proto/v47/types.py,sha256=zRu6eA_I6Jl1egHZiYLAAsprMQ3frahCJCeztGhPW2Q,4422
 cubelib/proto/version_independent/ClientBound.py,sha256=YIJBNlsGJ2KJBH-DxsWK2UFUDgGHfACteqBHhoLXeT8,813
 cubelib/proto/version_independent/ServerBound.py,sha256=VLz6b9ibxmNwqARiA7TohSM-29bVtKjaX6S3mfkZUBg,847
 cubelib/proto/version_independent/__init__.py,sha256=3FbHDIzwsqEHsU8YLZkfow8LAPX4Imx-IoCc10WcMW4,88
-cubelib-1.0.5rc2.dist-info/LICENSE,sha256=0LGBg5zdfKmHPwkm_qf-UEMVFViaolBPuhsJshQkdtU,35063
-cubelib-1.0.5rc2.dist-info/METADATA,sha256=NS_qmO0U1yCyu0nVTh6JqmUmJC-UQl7nrNHrUC0QkAc,1559
-cubelib-1.0.5rc2.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-cubelib-1.0.5rc2.dist-info/entry_points.txt,sha256=8_TdCgjBC4FL7TmwH9eZ6_irKyztLUWqDEQMKnuOlWM,51
-cubelib-1.0.5rc2.dist-info/top_level.txt,sha256=V-A5WIBNJEBLeFdORb0pkgbrf8-rsyDShHUIXfixums,8
-cubelib-1.0.5rc2.dist-info/RECORD,,
+cubelib-1.0.7.dist-info/LICENSE,sha256=0LGBg5zdfKmHPwkm_qf-UEMVFViaolBPuhsJshQkdtU,35063
+cubelib-1.0.7.dist-info/METADATA,sha256=JRowZlDYh3VrRqFFRODmBgaIcFcZ-VXz2thYOFwNxSg,1556
+cubelib-1.0.7.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
+cubelib-1.0.7.dist-info/entry_points.txt,sha256=8_TdCgjBC4FL7TmwH9eZ6_irKyztLUWqDEQMKnuOlWM,51
+cubelib-1.0.7.dist-info/top_level.txt,sha256=V-A5WIBNJEBLeFdORb0pkgbrf8-rsyDShHUIXfixums,8
+cubelib-1.0.7.dist-info/RECORD,,
```

